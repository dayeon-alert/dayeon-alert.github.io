[ { "title": "격자판 최대합 - 자바스크립트 알고리즘 문제풀이(2-6)", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4_2-6_%EA%B2%A9%EC%9E%90%ED%8C%90-%EC%B5%9C%EB%8C%80%ED%95%A9/", "categories": "Algorithm, 자바스크립트 알고리즘 문제풀이", "tags": "javascript, algorithm, inflearn", "date": "2022-07-05 08:50:00 +0900", "snippet": "▣ 입력설명 첫 줄에 자연수 N이 주어진다.(1&amp;lt;=N&amp;lt;=50) 두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 각 자연수는 100을 넘지 않는 다.▣ 출력설명 각 행의 합, 각 열의 합, 두 대각선의 합 중 가장 큰 합을 출력합니다.▣ 입력예제 110 13 10 12 15 12 39 30 23 11 11 25 50 53 15 19 27 29 37 27 19 13 30 13 19▣ 출력예제 1155function solution(arrNum){ let max = Number.MIN_SAFE_INTEGER; let sum1 = sum2 = sum3 = sum4 = 0; for (let i = 0; i &amp;lt; arrNum.length; i++) { sum1 = sum2 = 0; for (let j = 0; j &amp;lt; arrNum.length; j++) { sum1 += arrNum[i][j]; sum2 += arrNum[j][i]; } max = Math.max(max, sum1, sum2); sum3 += arrNum[i][i]; sum4 += arrNum[i][arrNum.length - i]; } max = Math.max(max, sum3, sum4); return max;}" }, { "title": "가운데 문자 출력 - 자바스크립트 알고리즘 문제풀이(15)", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4_15_%EA%B0%80%EC%9A%B4%EB%8D%B0_%EB%AC%B8%EC%9E%90_%EC%B6%9C%EB%A0%A5/", "categories": "Algorithm, 자바스크립트 알고리즘 문제풀이", "tags": "javascript, algorithm, inflearn", "date": "2022-06-14 08:00:00 +0900", "snippet": "▣ 입력설명 첫 줄에 문자열이 입력된다. 문자열의 길이는 100을 넘지 않습니다. ▣ 출력설명 첫 줄에 가운데 문자를 출력합니다. 단 단어의 길이가 짝수일 경우 가운데 2개의 문자를 출력합니다.▣ 입력예제 1 study ▣ 출력예제 1 u ▣ 입력예제 2 good ▣ 출력예제 2 oofunction solution(s){ let answer; let mid = Math.floor(s.length / 2); if (s.length % 2 == 1) answer = s.substring(mid, mid + 1); else answer = s.substring(mid - 1, mid + 1); return answer;}function solution2(s) { let answer; let mid = Math.floor(s.length / 2); if (s.length % 2 == 1) answer = s.substr(mid, 1); else answer = s.substring(mid - 1, 2); return answer;} str.substring(indexStart[, indexEnd]) : string 객체의 시작 인덱스로부터 종료 인덱스 전까지 문자열의 부분 문자열을 반환 str.substr(start[, length]) : 문자열에서 특정 위치에서 시작하여 특정 문자 수 만큼의 문자들을 반환" }, { "title": "A를", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4_9_A%EB%A5%BC_-%EC%9C%BC%EB%A1%9C/", "categories": "Algorithm, 자바스크립트 알고리즘 문제풀이", "tags": "javascript, algorithm, inflearn", "date": "2022-06-12 08:00:00 +0900", "snippet": "▣ 입력설명 첫 번째 줄에 문자열이 입력된다. ▣ 출력설명 첫 번째 줄에 바뀐 단어를 출력한다. ▣ 입력예제 1 BANANA ▣ 출력예제 1 B#N#N#function solution(s){ let answer = s; answer = answer.replace(/A/g, &quot;#&quot;); return answer;} /A/는 첫번째 A만 바꾸며, /A/g 정규식을 사용해야 A가 들어가는 문자 전부를 교체할 수 있다. String(문자열)의 경우 배열 객체처럼 주소 참조가 되지 않고 값이 복사된다. 즉, s와 answer의 값이 별개이기 때문에 s를 replace할 경우 answer의 값이 변경되지 않으므로 answer를 replace 해야 한다. 배열 역시 slice를 사용해 깊은 복사가 가능하다." }, { "title": "자바스크립트 알고리즘 문제풀이(8) - 일곱난쟁이", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4_8_%EC%9D%BC%EA%B3%B1%EB%82%9C%EC%9F%81%EC%9D%B4/", "categories": "Algorithm, 자바스크립트 알고리즘 문제풀이", "tags": "javascript, algorithm, inflearn", "date": "2022-06-10 08:00:00 +0900", "snippet": "▣ 입력설명 아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다. ▣ 출력설명 입력된 순서대로 일곱 난쟁이의 키를 출력한다. ▣ 입력예제 1 20 7 23 19 10 15 25 8 13 ▣ 출력예제 1 20 7 23 19 10 8 13function solution(arrHeight) { let answer = arrHeight, sum = arrHeight.reduce((a, b) =&amp;gt; a + b, 0); for (let i = 0; i &amp;lt; arrHeight.length - 1; i++) { for (let j = i + 1; j &amp;lt; arrHeight.length; j++) { if (sum - arrHeight[i] - arrHeight[j] !== 100) continue; arrHeight.splice(j, 1); arrHeight.splice(i, 1); return answer; } } return -1;}let arrNum = [[20, 7, 23, 19, 10, 15, 25, 8, 13]];for (let i = 0; i &amp;lt; arrNum.length; i++) { console.log(solution(arrNum[i]));} 얕은 복사 : answer와 arrHeight는 메모리에 위치한 똑같은 배열을 가리킨다. 따라서 arrHeight를 변경하면 answer 값 역시 동일한 값으로 변경된다. arrHeight.reduce((a,b) =&amp;gt; a + b, 0)의 경우 a에 b 값을 누적하며 초기값은 0으로 설정한다는 뜻이다." }, { "title": "자바스크립트 알고리즘 문제풀이(6) - 홀수", "url": "/posts/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4_6_%ED%99%80%EC%88%98/", "categories": "Algorithm, 자바스크립트 알고리즘 문제풀이", "tags": "javascript, algorithm, inflearn", "date": "2022-06-07 08:00:00 +0900", "snippet": "7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고, 고른 홀수들 중 최소값을 찾는 프로그램을 작성하세요. 예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53, 85이므로 그 합은 77 + 41 + 53 + 85 = 256 이 되고, 41 &amp;lt; 53 &amp;lt; 77 &amp;lt; 85 이므로 홀수들 중 최소값은 41이 된다. ▣ 입력설명 첫 번째 줄에 자연수 7개가 주어진다. 주어지는 자연수는 100보다 작다. 홀수가 한 개 이상 반드시 존재한다. ▣ 출력설명 첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최소값을 출력한다. ▣ 입력예제 1 12 77 38 41 53 92 85 ▣ 출력예제 1 256 41function solution(arr) { let answer; let sum = 0, min = 0; for (let x of arr) { if (x % 2 === 0) continue; if (min == 0 || x &amp;lt; min) min = x; sum += x; } answer.push(sum); answer.push(min); return answer;}let arrNum = [[12, 77, 38, 41, 53, 92, 85], [5, 3, 7, 11, 2, 15, 17]];for (let i = 0; i &amp;lt; arrNum.length; i++) { console.log(solution(arrNum[i]));} 코딩 테스트 시에는 변수명이 중요하다. 한 코드를 짤 때는 ==와 === 중 하나만 선택해서 통일할 것 sum += x는 연산자가 하나인 반면 sum = sum + x는 두 개의 연산자를 사용하기 때문에 시간이 더 걸린다." }, { "title": "JS로 Java 라이브러리 설치하기", "url": "/posts/JS%EB%A1%9C_Java_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC_%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/", "categories": "Blogging, Work", "tags": "java, work", "date": "2022-06-07 07:00:00 +0900", "snippet": "발단2020년, Flash Player의 지원이 종료되었다. 문제는 그 이후였다. 윈도우를 업데이트하기 이전에는 프로그램에서 여전히 플래시가 작동했는데, 사용자들이 윈도우를 업데이트하면서 더이상 플래시가 보이지 않게 된 것이었다. 사용자들에게 윈도우를 업데이트하지 말라고 할 수는 없는 노릇이었다. 의문의 폴더와 함께 미션을 받았다. 이걸 이용해 화면 단에 플래시를 사용하지 않고도 차트를 구현할 수 있도록 시도해보아라. 폴더 이름은 jfreechart-1.5.3이었다. 이 이야기는 신입의 처참한 실패에 대한 연대기다. 요약하자면Q. JS 파일로 Java 라이브러리 설치를 할 수 있나요?(생략)A. 아니요.여기서의 생략에 관한 이야기이다. 물론 가능할 수도 있다. 만약 방법을 알고 있다면 언제든 연락 주시길… …전개먼저 해당 폴더의 출처가 어디인지부터 추적하고 해당 프로그램에 대해 알아보았다. 파일의 출처는 이곳(jfreechart-1.5.3). JFreeChart는 무료 자바 차트 라이브러리로 많은 사람들이 이클립스에서 해당 라이브러리를 활용해 웹에서 차트를 구현하고 있었다.그런데 우리 회사가 다루고 있는 건… … CS지 웹이 아닌데. 어떻게 해야 자바 차트 라이브러리를 웹이 아닌 화면에 구현할 수 있지? 여기서 CS란?Client Server의 줄임말이다. Server에서 데이터를, 클라이언트에서 UI를 담당하는 형태의 모델. 속도가 빠른 대신 특정 OS 및 하드웨어에 종속적이라는 단점이 있다.반면 Web은 OS와 브라우저에 상관없이 어디서든 동작이 가능한 모델을 의미한다.일반적으로 실행 프로그램이 클라이언트에 설치가 되는지의 여부에 따라 둘을 구분한다.위기클라이언트에 해당 라이브러리를 가져오는 방법을 도무지 알 수가 없었다. 자료를 찾는 내내 신입 6개월의 시간이 파노라마처럼 흘러갔다. 누구라도 좋으니 계시를 내려주길 간절히 바랬지만 그런 일은 일어나지 않았다. 지금 생각해보면 물을 떠놓고 빌었어야 했나.웹사이트를 아무리 뒤져봐도 Java에서 해당 라이브러리를 설치해 웹에서 구현하는 방법만 있을 뿐이었다. 애초에 나는 Java를 잘 알지 못했다. 100% Java chart library를 화면과 연동시키는 방법이 도무지 떠오르지 않았다. 분명 11년 전의 글에는 JFreeChart가 호환되는 것 같다는 글이 도시전설처럼 남아있는데 정작 호환되는 방법은 남아있지 않았다.한참 씨름을 하다 결국 마음을 비우고 내가 할 수 있는 데까지만 하기로 했다. 그러니까, 먼저 자바 내에 해당 라이브러리를 설치하는 것.물론 성공했다면 이 글의 발단에 그런 비극적인 이야기가 적히진 않았을 것이다. 삶은 뜻대로 되지 않는 법이니까. (tmi. 신입일 경우 확률 두배로 증가함.)침착하게 자바에서 JFreeChart를 사용하는 방법부터 검색해보았다. 이클립스의 프로젝트에서 마우스 우클릭을 한다. Configure Build Path를 클릭한다. Java Build Path에서 Libraries 탭을 클릭한 다음 Add External JARs 버튼을 누른다. 압축해제한 jfreechart-1.0.19.zip 내부의 lib 폴더에서 jcommon-1.0.23.jar 파일과 jfreechart-1.0.19.jar파일 두 개를 찾아서 추가한다.내가 받은 jfreechart-1.5.3의 lib 파일에는 jfreechart_utils.js 파일만 있을 뿐 jar 파일은 없었다.식은땀이 나기 시작했다. 버전이 달라진다고 해서 이렇게 한순간에 확장자에 격변이 일어날 수 있는 것인가? js 파일을 어거지로 라이브러리에 추가해보려고 했다. 당연히 되지 않았다. 새삼스럽게 내가 무지하다는 걸 깨달았다.비유를 하자면 젓가락을 콘센트에 끼워넣고 있는데 이게 잘못된 건지도 모르는 상황에 처한 것 같았다(아마 실제로도 비슷했을 거다). 시켰으니 해내고 싶은데, 하다 못해 어떤 사유로 안 되는지 명확하게 보고를 올리고 싶은데 어떻게 해야 할지 이게 왜 안 되는지 감이 잡히지 않았다. 다른 분께 조언을 구하면 가능할 것 같은데?라는 답변이 돌아왔다. 포기할 수가 없었다.절정너무 답답해서 트위터에 트윗을 올렸다. 팔로워가 두 명인 지극히 작고 아담한 계정이지만 달리 말할 곳이 없었다. Java에서 라이브러리를 추가할 때 js 파일도 가능한지 모르겠다. 라는 지극히 추상적인 내용이었다.그런데 답글이 달렸다. 어떤 경우인지 뭘 바라시는지를 상세하게 적으세요(@darjeelingt)이제껏 마주한 모든 컴파일 에러를 걸고 답이 달릴 줄 몰랐다. 누군가에게 도움을 받을 수 있을 거란 기대조차 하지 않고 있었기 때문에… 평소보다 심박수가 빠르게 뛰었다. 침착하게 내가 마주한 문제점에 대해서 글로 적기 시작했다.머리 속에서 추상적으로 남아 있는 문제를 텍스트로 구체화하는 게 생각만큼 쉽지 않았고, 상대가 제대로 이해했을지에 대한 불안감도 있었지만 이 문제를 해결하고픈 욕망이 더 컸다. 그렇게 트윗을 보낸 뒤 상대에게 다시 답이 왔고, 해당 이슈에 대해 조언을 받을 수 있었다. Java에 라이브러리를 추가할 때는 반드시 Jar 파일이 필요하다. (이 때 안에 JS 파일이 존재할 수는 있다.) 만약 zip으로 파일을 받은 경우, 소스만 받은 거기 때문에 별도로 빌드된 파일을 받아야 한다. (다운로드 링크) 이후 빌드 과정을 거쳐야 하는데 거기에 설정을 넣으면 알아서 받아준다. 추가적으로 Maven과 관련된 글을 보내주셨다. (해당 사이트의 링크) Maven은 Java 기반 프로젝트의 빌드 도구(프로젝트 생성, 테스트 빌드, 배포 등의 작업을 위한 전용 프로그램)인데. 라이브러리 관리 기능을 포함하고 있다.Java로 개발할 때 settings.xml 또는 pom.xml과 같은 특정 문서에 필요한 라이브러리를 정의하면 Maven이 알아서 해당 라이브러리를 다운, 설치와 경로 지정까지 완료한다.Maven이 지원하는 다양한 패키지 형식에는 Jar(Java Archive) 파일이 있는데 Jar은 하나 이상의 class를 포함하는 zip 압축 패키지이다.결론적으로 내가 가지고 있는 파일로는 라이브러리 설치가 불가능하다는 것.결말한결 편안한 마음으로 회사에 보고를 올렸다. 혼자서 해당 파일로는 애초 설치가 불가능한 것인지, 단순히 내 역량의 문제인지 고민하는 것과 주변에서 내가 고민하고 있는 문제점을 듣고 이것이 불가능하다 알려주고 상세한 조언을 주는 것은 천양지차라는 것을 깨달았다. 조언이 없었다면 아마 지금도 고민하고 있었을지도 모르겠다. 벌써 등골에 소름이 돋는다. 여름이 무섭지 않다.도움을 주신 분께 감사를 어떻게 전해야 할지 줄곧 고민했다. 내가 할 수 있는 건 해당 이슈에 대해 최대한 상세하게 기록하고, 해당 개념을 숙지해 비슷한 일이 일어나지 않도록 주의하는 것이라는 생각이 들었다. 내가 해당 이슈를 할애하는데 투자한 시간이 귀하듯, 도움을 주는 이 역시 자신의 시간을 내어준 것이니 그것이 최소한의 도리고 예의가 아닐까.그래서 많이 미숙한 실력임에도 이렇게 글을 적는다. 해당 이슈를 해결하기까지는 적잖은 시간이 걸렸는데 막상 글로 적으니 얼마 되지 않는 듯해 기분이 묘하다. 미래의 내가 이 글을 보며 사소한 걸로 큰 고민을 했구나, 라고 여길 수 있기를 바라며, 다시 한 번 조언을 주신 darjeelingt님에게 진심으로 감사 인사를 올린다." }, { "title": "220517", "url": "/posts/220517SQLD/", "categories": "Study, SQL", "tags": "sql, til, study", "date": "2022-05-17 23:30:00 +0900", "snippet": "Ⅱ. 뷰(View) 가상 테이블. 실제 데이터를 저장하지 않고 해당 데이터를 조회해오는 SELECT문만 가지고 있다. 보안성 : 보안이 필요한 컬럼을 가진 테이블일 경우 해당 컬럼을 제외한 별도의 뷰를 생성하여 제공함으로써 보안을 유지할 수 있다. 독립성 : 테이블 스키마가 변경되었을 경우 어플리케이션은 변경하지 않고 관련 뷰만 수정한다. 편리성 : 복잡한 쿼리 구문을 뷰명으로 단축시킴으로써 가독성을 높이고 편리하게 사용할 수 있다. Ⅲ. 집합 연산자UNION ALL각 쿼리의 결과 집합의 합집합이다. 중복된 행도 그대로 출력된다.UNION각 쿼리의 결과 집합의 합집합이다. 중복된 행은 한 줄로 출력된다.INTERSECT각 쿼리의 결과 집합의 교집합이다. 중복된 행은 한 줄로 출력된다.MINUS/EXCEPT앞에 있는 쿼리의 결과 집합에서 뒤에 있는 쿼리의 결과 집합을 뺀 차집합이다. 중복된 행은 한 줄로 출력된다.Ⅳ. 그룹함수 집계 함수 : COUNT, SUM, AVG, MAX, MIN 등 소계(총계) 함수 : ROLLUP, CUBE, GROUPING SETS 등1. ROLLUP소그룹 간의 소계 및 총계를 계산하는 함수. ROLLUP (A) : A로 그룹핑, 총합계 ROLLUP (A, B) : A, B로 그룹핑, A로 그룹핑, 총합계 ROLLUP (A, B, C) : A, B, C로 그룹핑, A, B로 그룹핑, A로 그룹핑, 총합계2. CUBE소그룹 간의 소계 및 통계를 다차원적으로 계산할 수 있는 함수. GROUP BY가 일방향으로 그룹핑하여 소계를 구했다면 CUBE는 조합할 수 있는 모든 그룹에 대한 소계를 집계. CUBE (A) : A로 그룹핑, 총합계 CUBE (A, B) : A, B로 그룹핑, A로 그룹핑, B로 그룹핑, 총합계 CUBE (A, B, C) : A, B, C로 그룹핑, A, B로 그룹핑, A, C로 그룹핑, B, C로 그룹핑, A로 그룹핑, B로 그룹핑, C로 그룹핑, 총합계3. GROUPING SETS GROUPING SETS (A, B) : A로 그룹핑, B로 그룹핑 GROUPING SETS (A, B, ( )) : A로 그룹핑, B로 그룹핑, 총합계 GROUPING SETS (A, ROLLUP(B)) : A로 그룹핑, B로 그룹핑, 총합계 GROUPING SETS (A, ROLLUP(B, C)) : A로 그룹핑, B, C로 그룹핑, B로 그룹핑, 총합계 GROUPING SETS (A, B, ROLLUP(C)) : A로 그룹핑, B로 그룹핑, C로 그룹핑, 총합계Tip) ROLLUP 함수는 인수의 순서에 따라 결과가 달라지며 CUBE 함수와 GROUPING SETS 함수는 인수의 순서가 바뀌어도 같은 결과를 출력한다.4. GROUPING GROUPING 함수는 ROLLUP, CUBE, GROUPING SETS 등과 함께 쓰이며 소계를 나타내는 ROW를 구분할 수 있게 해준다. GROUPING을 사용하지 않을 경우 소계를 나타내는 Row에서 그룹핑의 기준이 되는 컬럼을 제외하고는 모두 NULL 값으로 표현되었지만 GROUPING 함수를 이용하면 원하는 위치에 원하는 텍스트를 출력할 수 있다. Oracle의 경우 DECODE 문으로 CASE문을 대체할 수 있다. 그룹핑하는 컬럼이 두 개일 때도 동일한 방법으로 쿼리를 작성해줄 수 있다. ROLLUP 함수와 마찬가지로 CUBE 함수와 GROUPING SETS 함수에도 동일한 방식으로 GROUPING 함수를 적용하여 쿼리를 작성할 수 있다." }, { "title": "220516", "url": "/posts/220516SQLD/", "categories": "Study, SQL", "tags": "sql, til, study", "date": "2022-05-16 23:30:00 +0900", "snippet": "Ⅱ. SELECT 문 SELECT 문장의 논리적인 실행 순서 : FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BYⅣ. WHERE절 논리 연산자는 SQL에 명시된 순서와는 관계없이 ( ) -&amp;gt; NOT -&amp;gt; AND -&amp;gt; OR 순으로 처리된다. 조건식에서 컬럼명은 일반적으로 좌측에 위치하지만 우측에 위치해도 정상적으로 동작한다. ‘_’ 혹은 ‘%’가 포함된 문자를 검색하고자 할 때 ESCAPE를 지정해서 쿼리를 작성할 수 있다. EXCAPE ‘#’로 지정해주면 ‘#%’ 혹은 ‘#_‘가 문자 그대로 인식될 수 있다.Ⅴ. GROUP BY, HAVING 절 SELECT절과 GROUP BY는 같은 컬럼으로 정의되어야 한다. HAVING 절은 주로 GROUP BY 절 뒤에 오면서 집계 데이터에 대한 조건을 부여하지만 테이블 전체가 한 개의 그룹이 되는 경우 HAVING만 단독으로 사용할 수 있다.Ⅵ. ORDER BY 절 ORDER BY 절 뒤에 오는 컬럼에는 ASC(Ascending) : 오름차순, DESC(Descending) : 내림차순 옵션이 붙을 수 있으며 옵션 생략 시 오름차순으로 정렬된다. 그리고 Oracle의 경우 NULL 값을 최댓값으로 취급한다. 다만, NULL 값을 가장 큰 값으로 간주하여 정렬할 것인지 가장 작은 값으로 간주하여 정렬할 것인지는 DBMS마다 다르다.Ⅶ. JOIN2. EQUI JOIN Equal(=) 조건으로 JOIN하는 것으로 가장 흔히 볼 수 있는 JOIN의 방식3. Non EQUI JOIN Equal(=) 조건이 아닌 다른 조건(BETWEEN, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=)으로 JOIN 하는 방식4. 3개 이상 TABLE JOIN JOIN 쿼리를 좀 더 확장해서 3개 이상의 테이블을 JOIN 할 수도 있다.5. OUTER JOIN JOIN 조건에 만족하지 않는 행들도 출력되는 형태. LEFT OUTER JOIN의 경우 LEFT TABLE과 RIGHT TABLE의 데이터 중 JOIN에 성공한 데이터와 JOIN에 성공하지 못한 나머지 LEFT TABLE의 데이터가 함께 출력. Oracle에서는 모든 행이 출력되는 테이블의 반대편 테이블 옆에 (+) 기호를 붙여 작성하면 된다.Ⅷ. STANDARD JOIN1. INNER JOIN JOIN 조건에 충족하는 데이터만 출력되는 방식. 앞서 본 SQL과의 차이점은 JOIN 조건을 ON 절을 사용해서 작성해야 한다는 점.2. OUTER JOIN JOIN 조건에 충족하는 데이터가 아니어도 출력될 수 있는 방식.1. LEFT OUTER JOINSQL에서 왼쪽에 표기된 테이블의 데이터는 무조건 출력되는 JOIN. 대신 오른쪽 테이블에 JOIN되는 데이터가 없는 Row들은 오른쪽 테이블 컬럼의 값이 NULL로 출력2. RIGHT OUTER JOINSQL에서 오른쪽에 표기된 테이블의 데이터는 무조건 출력되는 JOIN. 대신 왼쪽 테이블에 JOIN되는 데이터가 없는 Row들은 왼쪽 테이블 컬럼의 값이 NULL로 출력3. FULL OUTER JOIN왼쪽, 오른쪽 테이블의 데이터가 모두 출력되는 방식. LEFT OUTER JOIN과 RIGHT OUTER JOIN의 합집합. (단, 중복값은 제거)3. NATURAL JOINA 테이블과 B 테이블에서 같은 이름을 가진 컬럼들이 모두 동일한 데이터를 가지고 있을 경우 JOIN이 되는 방식.Oracle에서는 USING 조건절을 이용하여 같은 이름을 가진 컬럼 중 원하는 컬럼만 JOIN에 이용할 수 있다.단, SELECT 절에서 USING 절로 정의된 컬럼 앞에는 별도의 ALIAS나 테이블명을 붙이지 않아야 한다. 공통 컬럼 앞에 OWNER 명을 붙이면 에러가 발생한다.4. CROSS JOINA 테이블과 B 테이블 사이에 JOIN 조건이 없는 경우, 조합할 수 있는 모든 경우를 출력하는 방식. 다른 말로 Cartesian Product라고 표현하기도 한다.Ch2-2. SQL 활용Ⅰ. 서브쿼리(Subquery)서브쿼리는 위치에 따라 다음과 같이 나눌 수 있다. SELECT 절 : 스칼라 서브쿼리 FROM 절 : 인라인 뷰 WHERE 절, HAVING 절 : 중첩 서브쿼리 다중 행 서브쿼리의 경우 ‘=’ 조건과 함께 사용할 수 없다. 다중 컬럼 서브쿼리의 경우 IN절과 함께 사용할 수 있다.1. 스칼라 서브쿼리 주로 SELECT 절에 위치, 하지만 UPDATE 문의 SET 절이나 ORDER BY 절에도 올 수 있다. (FROM 절은 불가능) 컬럼 대신 사용되므로 반드시 하나의 값만을 반환해야 하며 아닌 경우 에러를 발생2. 인라인 뷰 FROM 절 등 테이블명이 올 수 있는 위치에 사용 가능3. 중첩 서브쿼리 WHERE 절과 HAVING 절에 사용할 수 있다. 중첩 서브쿼리는 메인 쿼리와의 관계에 따라 나눌 수 있다. 비연관 서브쿼리 : 메인 쿼리와 관계를 맺고 있지 않음. 서브쿼리 내에 메인 쿼리의 컬럼이 존재하지 않음 연관 서브쿼리 : 메인 쿼리와 관계를 맺고 있음. 서브쿼리 내에 메인 쿼리의 컬럼 존재 중첩 서브쿼리는 반환하는 데이터 형태에 따라 다음과 같이 나눌 수 있다. 단일 행(Single Row) 서브쿼리 : 서브쿼리가 항상 1건 이하의 데이터를 반환, 단일 행 비교 연산자(-, &amp;lt;. &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;)와 함께 사용 다중 행(Multi Row) 서브쿼리 : 서브쿼리가 여러 건의 데이터(2건 이상의 행)를 반환, 다중 행 비교 연산자(IN, ALL, ANY, SOME, EXISTS)와 함께 사용 다중 컬럼(Multi Column) 서브쿼리 : 서브쿼리가 여러 컬럼의 데이터를 반환 " }, { "title": "220512", "url": "/posts/220512SQLD/", "categories": "Study, SQL", "tags": "sql, til, study", "date": "2022-05-12 23:30:00 +0900", "snippet": "Ch2. SQL 기본Ⅰ. 관계형 데이터베이스 개요2. 관계형 데이터베이스 RDB(Relational Database)라고 부른다. 관계형 데이터 모델에 기초를 둔 데이터베이스이다. RDBMS(Relational Database Management System)는 이러한 RDB를 관리, 감독하기 위한 시스템이며 우리가 익히 알고 있는 Oracle, SQL Server(MSSQL), MySQL, MariaDB, PostgreSQL 등이 이에 속한다.3. TABLE 세로 열을 컬럼(Column), 가로 행을(Row)라고 한다. 데이터 모델에서 인스턴스에 해당하는 것은 로우, 속성에 해당하는 것은 컬럼. 테이블은 관계형 데이터베이스의 기본 단위이고 데이터베이스는 여러 개의 테이블로 구성된다. 이렇게 데이터를 저장하는 주된 목적은 데이터를 활용하는 데에 있고 우리는 그것을 테이블 형태로 조회, 변경, 삭제할 수 있다. 데이터 모델에서 엔터티에 해당된다.4. SQL(Structured Query Language) SQL은 관계형 데이터베이스에서 데이터를 다루기 위해 사용하는 언어이다.Ⅱ. SELECT문1. SELECT *(asterisk)를 쓰면 전체 컬럼이 조회되며 조회되는 컬럼의 순서는 테이블 컬럼 순서와 동일 테이블명 혹은 컬럼명에 별도의 별칭(Alias)을 붙여줄 수 있다.2. 산술 연산자 NUMBER DATE 유형의 데이터와 같이 사용할 수 있다.3. 합성 연산자 문자와 문자를 연결할 때 사용하는 연산자이다. SELECT &#39;S&#39; || &#39;Q&#39; || &#39;L&#39; AS SQLDFROM DUAL; Ⅲ. 함수1. 문자 함수 CHR(ASCII 코드) CHR(65) -&amp;gt; A LOWER(문자열) LOWER(&#39;JENNIE&#39;) -&amp;gt; jennie UPPER(문자열) UPPER(&#39;jennie&#39;) -&amp;gt; JENNIE LTRIM(문자열, [,특정 문자]) *[ ]는 옵션특정 문자를 따로 명시해주지 않으면 문자열의 왼쪽 공백 제거, 명시했을 경우 문자열의 왼쪽부터 한 글자씩 특정 문자와 비교하여 특정 문자에 포함되어 있으면 제거하고 포함되지 않았으면 멈춘다. LTRIM(&#39;ㅤJENNIE&#39;) -&amp;gt; JENNIE LTRIM(&#39;블랙핑크&#39;, &#39;블랙&#39;) -&amp;gt; 핑크 RTRIM(문자열, [,특정 문자]) *[ ]는 옵션특정 문자를 따로 명시해주지 않으면 문자열의 오른쪽 공백 제거, 명시했을 경우 문자열의 오른쪽부터 한 글자씩 특정 문자와 비교하여 특정 문자에 포함되어 있으면 제거하고 포함되지 않았으면 멈춘다. LTRIM(&#39;JENNIEㅤ&#39;) -&amp;gt; JENNIE LTRIM(&#39;블랙핑크&#39;, &#39;핑크&#39;) -&amp;gt; 블랙 TRIM([위치] [특정 문자] [FROM] 문자열 ) *[ ]는 옵션 옵션이 하나도 없을 경우 문자열의 왼쪽과 오른쪽 공백을 제거 그렇지 않을 경우 문자열을 위치(LEADING or TRAILING or BOTH)로 지정된 곳부터 한 글자씩 특정 문자와 비교하여 같으면 제거, 같지 않으면 멈춘다. LTRIM, RTRIM과 달리 특정 문자는 한 글자만 지정할 수 있다. TRIM(&#39;ㅤJENNIEㅤ&#39;) -&amp;gt; JENNIE TRIM(LEADING &#39;블&#39; FROM &#39;블랙핑크&#39;) -&amp;gt; 랙핑크 TRIM(TRAILING &#39;크&#39; FROM &#39;블랙핑크&#39;) -&amp;gt; 블랙핑 SUBSTR(문자열, 시작점 [,길이]) * [ ]는 옵션 SUBSTR(&#39;블랙핑크제니&#39;, 3, 2) -&amp;gt; 핑크 LENGTH(문자열) LENGTH(&#39;JENNIE&#39;) -&amp;gt; 6 REPLACE(문자열, 변경 전 문자열 [,변경 후 문자열]) * [ ]는 옵션 REPLACE(&#39;블랙핑크제니&#39;, &#39;제니&#39;, &#39;지수&#39;) -&amp;gt; 블랙핑크지수 2. 숫자 함수 ABS(수) ABS(-1) -&amp;gt; 1 ABS(2) -&amp;gt; 2 SIGN(수)수의 부호를 반환해주는 함수이다. 양수이면 1, 음수이면 -1, 0이면 0을 반환한다. SIGN(-7) -&amp;gt; -1 SIGN(7) -&amp;gt; 1 ROUND(수 [,자릿수]) *[ ]는 옵션 ROUND(163.76, 1) -&amp;gt; 163.8 ROUND(163.76, -2) -&amp;gt; 200 TRUNC(수 [,자릿수]) *[ ]는 옵션 TRUNC(54.29, 1) -&amp;gt; 54.2 TRUNC(54.29, -1) -&amp;gt; 50 CEIL(수) CEIL(72.86) -&amp;gt; 73 CEIL(-33.4) -&amp;gt; 33 FLOOR(수) FLOOR(22.3) -&amp;gt; 22 FLOOR(-22.3) -&amp;gt; -23 MOD(수1, 수2) MOD(15, 7) -&amp;gt; 1 MOD(15, -4) -&amp;gt; 3 3. 날짜 함수 SYSDATE현재의 연, 월, 일, 시, 분, 초를 반환해주는 함수(nls_data_format에 따라서 sysdate의 출력 양식은 달라질 수 있음) EXTRACT(특정 단위 FROM 날짜 데이터)날짜 데이터에서 특정 단위(YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)만을 출력해서 반환해주는 함수이다. ADD_MONTHS(날짜 데이터, 특정 개월 수)날짜 데이터에서 특정 개월 수를 더한 날짜를 반환해주는 함수.날짜의 이전 달이나 다음 달에 기준 날짜의 일자가 존재하지 않으면 해당 월의 마지막 일자가 반환된다. ADD_MONTHS(TO_DATE(&#39;2021-12-31&#39;, &#39;YYYY-MM_DD&#39;), -1) -&amp;gt; 2021-11-30 4. 변환 함수 명시적 형변환과 암시적 형변환 명시적 형변환 : 변환 함수를 사용하여 데이터 유형 변환을 명시적으로 나타냄 암시적 형변환 : 데이터베이스가 내부적으로 알아서 데이터 유형을 변환함 명시적 형변환에 쓰이는 함수a. TO_NUMBER(문자열)문자열을 숫자형으로 변환해주는 함수.b. TO_CHAR(수 or 날짜 [, 포맷]) * [ ]는 옵션수나 날짜형의 데이터를 포맷 형식의 문자형으로 변환해주는 함수. TO_CHAR(SYSDATE, &#39;YYYYMMDD HH24MISS&#39;) -&amp;gt; 20210921 223321 c. TO_DATE(문자열, 포맷)포맷 형식의 문자형의 데이터를 날짜형으로 변환해주는 함수. TO_DATE(&#39;20210602&#39;, &#39;YYYYMMDD&#39;) -&amp;gt; 2021-06-02 5. NULL 관련 함수 NVL(인수, 인수2)NVL(REVIEW_SCORE, 0) -&amp;gt; REVIEW_SCORE(컬럼) 데이터가 NULL일 경우 0을 반환하고 NULL이 아닐 경우 REVIEW_SCORE 값을 반환 NULLIF(인수1, 인수2)NULLIF(REVIEW_SCORE, 0) -&amp;gt; REVIEW_SCORE(컬럼) 데이터가 0일 경우 NULL을 반환하고 0이 아닐 경우 REVIEW_SCORE 값을 반환6. CASECASE WHEN SUBWAY_LINE = &#39;1&#39; THEN &#39;BLUE&#39; WHEN SUBWAY_LINE = &#39;2&#39; THEN &#39;GREEN&#39; WHEN SUBWAY_LINE = &#39;3&#39; THEN &#39;ORANGE&#39; [ELSE &#39;GRAY&#39;]ENDCASE SUBWAY_LINE WHEN &#39;1&#39; THEN &#39;BLUE&#39; WHEN &#39;2&#39; THEN &#39;GREEN&#39; WHEN &#39;3&#39; THEN &#39;ORANGE&#39; [ELSE &#39;GRAY&#39;]ENDDECODE(SUBWAY_LINE, &#39;1&#39;, &#39;BLUE&#39;, &#39;2&#39;, &#39;GREEN&#39;, &#39;3&#39;, &#39;ORANGE&#39;[,&#39;GRAY&#39;])" }, { "title": "220511", "url": "/posts/220511SQLD/", "categories": "Study, SQL", "tags": "sql, til, study", "date": "2022-05-11 23:00:00 +0900", "snippet": "Ⅱ. 반정규화(De-Normalization) 반정규화는 데이터의 조회 성능을 향상시키기 위해 데이터의 중복을 허용하거나 데이터를 그룹핑하는 과정이다. 정규화를 했을 때 조회 성능이 심각하게 저하되는 경우 반정규화를 고려해 볼 수 있다. 반정규화를 하면 데이터 무결성이 저해된다고 볼 수 있다. 반정규화를 하면 입력, 수정, 삭제 성능이 저하될 수 있다. 반정규화를 하면 데이터 정합성 이슈가 발생할 수 있다. 반정규화의 과정은 정규화가 끝난 후 거치게 된다. 반정규화는 모든 정규화를 마친 후 성능상 이슈가 있을 때만 고려하는 것이 원칙이다.1. 테이블 반정규화테이블 병합 1:1 관계 테이블 병합 1:M 관계 테이블 병합 슈퍼 서브 타입 테이블 병합테이블 분할 테이블 수직 분할(속성 분할) 테이블 수평 분할(인스턴스 분할, 파티셔닝)테이블 추가 중복 테이블 추가 통계 테이블 추가 이력 테이블 추가 부분 테이블 추가 테이블 병합업무 프로세스상 JOIN이 필요한 경우가 많아 테이블을 통합하는 것이 성능 측면에서 유리할 경우 고려.1:M 관계 테이블 병합의 경우 1쪽에 해당하는 엔터티의 속성 개수가 많으면 병합했을 경우 중복 데이터가 많아지므로 테이블 병합에 적절하지 못함. 테이블 분할a. 테이블 수직 분할 : 엔터티의 일부 속성을 별도의 엔터티로 분할(1:1 관계 성립), 자주 사용하는 속성이 아니거나 대부분의 인스턴스가 해당 속성값을 NULL로 갖고 있을 때 고려b. 테이블 수평 분할 : 엔터티의 인스턴스를 특정 기준으로 별도의 엔터티로 분할(파티셔닝), 테이블 수평 분할의 기준은 주로 기간이지만 다른 속성이 될 수도 있다. 테이블 추가a. 중복 테이블 추가 : 데이터의 중복을 감안하더라도 성능상 반드시 필요하다고 판단되는 경우 별도의 엔터티를 추가한다.b. 통계 테이블 추가 : 통계치를 미리 계산하여 저장한다.c. 이력 테이블 추가 : 이력 테이블에서 과거의 데이터를 관리한다.d. 부분 테이블 추가 : 특정 프로세스 수행에 필요한 정보만 부분 테이블로 생성한다. 2. 컬럼 반정규화 중복 컬럼 추가 파생 컬럼 추가 이력 테이블 컬럼 추가3. 관계 반정규화(중복관계 추가) 업무 프로세스상 JOIN이 필요한 경우가 많아 중복 관계를 추가하는 것이 성능 측면에서 유리할 경우 고려한다.Ⅲ. 트랜잭션 데이터를 조작하기 위한 하나의 논리적인 작업 단위Ⅳ. NULL NULL은 존재하지 않음, 즉 값이 없음을 의미한다. 가로 연산 : NULL이 포함되어 있으면 결과값은 NULL이 된다. 세로 연산 : 다른 인스턴스의 데이터와 연산할 때는 NULL 값을 제외한다." }, { "title": "220510", "url": "/posts/220510SQLD/", "categories": "Study, SQL", "tags": "sql, til, study", "date": "2022-05-10 23:30:00 +0900", "snippet": "Ⅴ. 식별자(Identifiers)1. 식별자란?식별자는 이런 속성 중에 각각의 인스턴스를 구분 가능하게 만들어주는 대표 격인 속성을 의미한다.2. 주식별자주식별자는 기본키, PK(Primary Key)에 해당하는 속성이다. 하나의 속성이 주식별자가 될 수도 있고 여러 개의 속성이 주식별자 될 수도 있다. 유일성 : 각 인스턴스에 유니크함을 부여하여 식별이 가능하도록 한다. 최소성 : 유일성을 보장하는 최소 개수의 속성이어야 한다. 불변성 : 속성값이 되도록 변하지 않아야 한다. 존재성 : 속성값이 NULL일 수 없다.3. 분류(★) 대표성 여부 주식별자(Primary Identifier) : 유일성, 최소성, 불변성, 존재성을 가진 대표 식별자, 다른 엔터티와 참조 관계로 연결 보조식별자(Alternate Identifier) : 인스턴스를 식별할 수는 있지만 대표 식별자가 아님, 다른 엔터티와 참조 관계로 연결되지 않음 스스로 생성되었는지 여부 내부식별자(Internal Identifier) : 엔터티 내부에서 스스로 생성된 식별자 외부식별자(Foreign Identifier) : 다른 엔터티에서 온 식별자, 다른 엔터티와의 연결고리 역할 단일 속성의 여부 단일식별자(Single Identifier) : 하나의 속성으로 구성된 식별자 복합식별자(Composite Identifier) : 두 개 이상의 속성으로 구성된 식별자 대체 여부 원조식별자(Original Identifier) : 업무 프로세스에 존재하는 식별자, 가공되지 않은 원래의 식별자(본질식별자) 대리식별자(Surrogate Identifier) : 주식별자의 속성이 두 개 이상인 경우 그 속성들을 하나로 묶어서 사용하는 식별자(인조식별자) 4. 식별자 관계 vs. 비식별자 관계 식별자 관계(Identification Relationship) 부모 엔터티의 식별자가 자식 엔터티의 주식별자가 되는 관계 주식별자는 반드시 존재해야 하므로(존재성) 부모 엔터티가 있어야 생성 가능 단일식별자인지 복합식별자인지에 따라 1:1이거나 1:M이거나가 결정된다. 비식별자 관계(Non-Identification Relationship) 부모 엔터티의 식별자가 자식 엔터티의 주식별자가 아닌 일반 속성이 되는 관계 일반 속성의 속성값은 NULL이 될 수 있으므로 부모 엔터티가 없는 자식 엔터티 생성이 가능 마찬가지의 이유로 자식 엔터티가 존재하는 상태에서 부모 엔터티가 삭제될 수도 있음 Ch2. 데이터 모델과 SQLⅠ. 정규화(Normalization) 정규화를 할수록 엔터티는 증가한다. 데이터 입력, 수정, 삭제 성능이 향상된다. 적절한 정규화는 성능상 이롭지만 지나친 정규화는 오히려 JOIN으로 인한 조회 성능 저하가 발생할 수 있다. 유사 속성에 모두 인덱스를 생성할 경우 조회 성능은 향상될지 모르나 입력, 수정, 삭제 성능은 오히려 저하되므로 무분별한 인덱스 생성은 지양해야 한다.제1정규형 모든 속성은 반드시 하나의 값만 가져야 한다. 유사한 속성의 반복 그룹 형태를 갖고 있으면 1차 정규화 대상이다.제2정규형 엔터티의 모든 일반속성은 반드시 모든 주식별자에 종속되어야 한다. 주식별자가 단일 식별자가 아닌 복합식별자인 경우 일반속성이 주식별자의 일부에만 종속될 수 있는데 이런 경우 문제점이 발생할 수 있다.제3정규형 주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다." }, { "title": "220509", "url": "/posts/220509SQLD/", "categories": "Study, SQL", "tags": "sql, til, study", "date": "2022-05-10 08:30:00 +0900", "snippet": "Ch1. 데이터 모델링의 이해Ⅰ. 데이터 모델의 이해1. 모델링이란? 데이터베이스의 모델링은 ‘현실 세계를 단순화하여 표현하는 기법’이다. 모델링이 갖춰야 할 조건 현실세계를 반영해야 한다. 단순화하여 표현해야 한다. 관리하고자 하는 데이터를 모델로 설계한다. 데이터 모델링을 할 때 지양해야 할 점 중복(Duplication) : 같은 데이터가 여러 엔터티에 중복으로 저장되는 현상을 지양해야 한다. 비유연성(Inflexibility) : 데이터 모델의 설계에 따라 어플리케이션의 사소한 변경에도 데이터 모델이 수시로 변경이 되어야 하는 상황이 생길 수 있다. 이런 상황은 시스템을 유지보수하는 데에 어려움을 가중시키므로 데이터 모델과 프로세스를 분리하여 유연성을 높이는 것이 바람직하다. 2. 모델링의 특징 추상화(Abstraction) : 현실 세계를 일정한 형식으로 표현하는 것이다. 즉, 아이디어나 개념을 간략하게 표현하는 과정이다. 단순화(Simplification) : 복잡한 현실 세계를 정해진 표기법으로 단순하고 쉽게 표현한다는 의미이다. 명확화(Clarity) : 불분명함을 제거하고 명확하게 해석할 수 있도록 기술한다는 의미이다. 데이터베이스의 모델링은 ‘현실세계를 추상화, 단순화, 명확화하기 위해 일정한 표기법은 의해 표현하는 기법’이다. 3. 모델링의 세 가지 관점 데이터 관점(What, Data) : 데이터 위주의 모델링이라고 할 수 있다. 어떤 데이터들이 업무와 얽혀있는지, 그리고 그 데이터 간에는 어떤 관계가 있는지에 대해서 모델링하는 방법이다. 프로세스 관점(How, Process) : 프로세스 위주의 모델링이라고 할 수 있다. 이 업무가 실제로 처리하고 있는 일은 무엇인지 또는 앞으로 처리해야 하는 일은 무엇인지를 모델링하는 방법이다. 데이터와 프로세스의 상관 관점(Data vs. Process, Interaction) : 데이터와 프로세스의 관계를 위주로 한 모델링이라고 할 수 있다. 프로세스의 흐름에 따라 데이터가 어떤 영향을 받는지를 모델링하는 방법이다.4. 모델링의 세 가지 단계 개념적 데이터 모델링(Conceptual Data Modeling) : 전사적 데이터 모델링 수행 시 행해지며 추상화 레벨이 가장 높은 모델링이다. 이 단계에서는 업무 중심적이고 포괄적인 수준의 모델링이 진행된다. 논리적 데이터 모델링(Logical Data Modeling) : 재사용성이 가장 높은 모델링으로 데이터베이스 모델에 대한 Key, 속성, 관계 등을 모두 표현하는 단계이다. 물리적 데이터 모델링(Physical Data Modeling) : 실제 데이터베이스로 구현할 수 있도록 성능이나 가용성 등의 물리적인 성격을 고려하여 모델을 표현하는 단계이다.5. 데이터의 독립성3단계 스키마 구조a. 외부 스키마(External Schema), 사용자의 관점 : Multiple User’s View 단계로 각 사용자가 보는 데이터베이스의 스키마를 정의한다. View 단계로 여러 개의 사용자 관점으로 구성되는 것b. 개념 스키마(Conceptual Schema), 통합된 관점 : Community View of DB 단계로 모든 사용자가 보는 데이터베이스의 스키마를 통합하여 전체 데이터베이스를 나타내는 것이다. 데이터베이스에 저장되는 데이터들을 표현하고 데이터들 간의 관계를 나타낸다. 모든 사용자 관점을 통합한 조직 전체 관점의 통합적인 표현c. 내부 스키마(Internal Schema), 물리적인 관점 : Physical Representation 단계로 물리적인 저장 구조를 나타낸다. 실질적인 데이터의 저장 구조나 컬럼 정의, 인덱스 등이 포함된다. 물리적인 저장 구조를 나타내는 것3단계 스키마 구조가 보장하는 독립성a. 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마는 영향받지 않는다.b. 물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향받지 않는다.6. ERD(Entity Relationship Diagram) ERD 표기 방식a. Peter Chen : 주로 대학교재에서 사용하는 표기법으로 실무에서 사용하는 경우는 드물다.b. IDEF1X(Integration Definition for Information Modeling) : 실무에서 사용하는 경우도 있으며 ERWin에서 사용되는 모델이기도 하다(ERWin은 ERD를 그리는 모델링 툴).c. IE/Crow’s Foot : 까마귀발 표기법이라고도 부르며 가장 많이 사용한다. ERWin, ERStudio에서 사용되는 모델이다(ERWin, ERStudio는 ERD를 그리는 모델링 툴).d. Min-Max/ISO : 각 엔터티의 참여도를 좀 더 상세하게 나타내느 표기법이다.e. UML : 소프트웨어 공학에서 주로 사용되는 모델이다.f. Case Method/Barker : Oracle에서 사용되는 모델로 Crow’s Foot과 비슷하다. ERD 작성 순서a. 엔터티를 도출하고 그린다.b. 엔터티를 적절하게 배치한다.c. 엔터티 간의 관계를 설정한다.d. 관계명을 기입한다.e. 관계의 참여도를 기입한다.f. 관계의 필수/선택 여부를 기입한다. 엔터티 : Table 인스턴스 : Row 속성 : Column Ⅱ. 엔터티(Entity)2. 엔터티의 특징 업무에서 쓰이는 정보여야 함 유니크함을 보장할 수 있는 식별자가 있어야 함 2개 이상의 인스턴스를 가지고 있어야 함 반드시 속성을 가지고 있어야 함 다른 엔터티와 1개 이상의 관계를 가지고 있어야 함3. 엔터티의 분류(★) 유형 vs. 무형 유형 엔터티 : 물리적인 형태 존재, 안정적, 지속적(상품, 회원) 개념 엔터티 : 물리적인 형태 없음, 개념적(부서, 학과) 사건 엔터티 : 행위를 함으로써 발생, 빈번함, 통계 자료로 이용 가능(주문, 이벤트 응모) 발생시점 기본 엔터티 : 독립적으로 생성되어 자신만의 주식별자를 가지며 다른 엔터티의 부모 역할을 함. 자식 엔터티를 가질 수 있음. 업무에 원래 존재하는 정보. (상품, 회원, 사원, 부서) 중심 엔터티 : 기본 엔터티로부터 파생되어 많은 데이터를 갖게 됨. 행위 엔터티 생성. 업무에 있어서 중심적인 역할을 하며 데이터의 양이 많이 발생. (주문, 매출, 계약) 행위 엔터티 : 2개 이상의 부모 엔터티로부터 파생. 보통 설계 초기 단계보다는 상세 설계단계에서 많이 도출됨. 데이터가 자주 변경되거나 증가할 수 있음(주문 내역, 이벤트 응모 이력) 엔터티의 이름을 정할 때 주의할 점 업무에서 실제로 쓰이는 용어 사용 한글은 약어를 사용하지 않고 영문은 대문자로 표기 단수 명사로 표현하고 띄어쓰기는 하지 않음 다른 엔터티와 의미상으로 중복될 수 없음(주문, 결제 엔터티는 중복될 수 있음) 해당 엔터티가 갖고 있는 데이터가 무엇인지 명확하게 표현Ⅲ. 속성(Attribute)3. 엔터티, 인스턴스, 속성, 속성값의 관계 한 개의 엔터티는 두 개 이상의 인스턴스를 갖는다. 한 개의 인스턴스는 두 개 이상의 속성을 갖는다. 한 개의 속성은 하나의 속성값을 갖는다.4. 분류a. 특성에 따른 분류 기본속성(Basic Attribute) 업무 프로세스 분석을 통해 바로 정의가 가능한 속성 설계속성(Designed Attribute) 업무에 존재하지는 않지만 설계하다 보니 필요하다고 판단되어 도출해낸 속성 파생속성(Derived Attribute) 다른 속성의 속성값을 계산하거나 특정한 규칙으로 변형하여 생성한 속성b. 구성방식에 따른 분류 PK(Primary Key)속성 : 엔터티의 인스턴스들을 식별할 수 있는 속성 FK(Foreign Key)속성 : 다른 엔터티의 속성에서 가져온 속성 일반속성 : PK, FK를 제외한 나머지 속성Ⅳ. 관계(Relationship)2. 존재 관계엄마와 아기처럼 존재 자체로 연관성이 있는 관계.ex) 직원과 부서, 학생과 학과 엔터티3. 행위 관계특정한 행위를 함으로써 연관성이 생기는 관계.ex) 회원과 주문, 학생과 출석부 엔터티4. 표기법(★) 관계명(Membership) : 관계의 이름 관계차수(Cardinality) : 관계에 참여하는 수 관계선택사양(Iptionality) : 필수인지 선택인지의 여부a. 관계명 바람직하지 않은 관계명 : 연관성이 있다, 관계가 있다, 출석을 했다. 바람직한 관계명 : 주문한다, 소속된다, 출석을 한다.b. 관계차수 각 엔터티에서 관계에 참여하는 수. 일반적으로 1:1, 1:M, M:N 형식으로 구분할 수 있다.c. 관계선택사양 필수적 관계 : 참여자가 반드시 존재해야 하는 관계 선택적 관계 : 참여자가 없을 수도 있는 관계" }, { "title": "220405", "url": "/posts/220405TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-04-06 08:30:00 +0900", "snippet": "1.데이터 저장이 정상적으로 되지 않으니 확인을 부탁한다는 요청이 왔다. 확인해보니 A 데이터를 B 컴포넌트에, B 데이터를 A 컴포넌트에 출력하고 있었다. 간단한 실수였는데빨리 찾지 못해서 오래 헤맸다. 또한 저장을 하는대로 저장 이력을 계속해서 추가하는 형태였는데, 저장 일시가 동일할 경우 추가가 아닌 업데이트의 형태로 기능 개선을 부탁한다고하셨다. 이 부분도 다시 고려를 해보려고 한다.2.트위터 API에서 타임라인의 경우 멘션에 비해 API Limit이 훨씬 빠르게 온다. 따라서 타임라인 조회 시간을 멘션 조회 시간보다 길게 설정하는 형태로 코드를 수정했다." }, { "title": "220404", "url": "/posts/220404TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-04-05 08:30:00 +0900", "snippet": "1.SQL에서 전송된 날짜값을 화면에서 출력하면 값이 다른 걸 확인했다. 확인해보니 날짜값의 경우 SQL에서 TO_CHAR(컬럼명, ‘yyyymmddhh24miss)라는 형태로 전달해야 화면에서 정상적으로 받을 수 있었다.2.영양도 분석은 항상 중요한 것 같다. A라는 직책의 스케줄 화면을 수정했는데, 이 때 A 뿐만 아니라 A와 연관이 있는 A’까지 고려를 하지 못했다. 다음 작업 시에는 유의할 것.3.트위터 API에서 새로운 멘션, 혹은 타임라인의 트윗을 불러올 때 특정 트윗을 기점으로 새로운 트윗을 불러올 수 있다. 본래 이 트윗을 구글 스프레드 시트에 저장하고 읽는 형태로 진행을 했는데, 문제는 Read Request Limit에 쉽게 걸린다는 단점이 있다. 여유가 된다면 해당 트윗 정보는 txt 파일에 저장하고 갱신하는 형태로 진행을 하려고 한다." }, { "title": "220331", "url": "/posts/220331TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-04-01 07:30:00 +0900", "snippet": "1.Heroku와 Github를 연동했다. CMD 창에서 해당 파일이 있는 폴더로 이동한 다음,git remote add origin https://github.com/dayeon-alert/[repositoryname].git을 입력해서 해당 파일을 Github와 원격으로 연동했다. 그 다음 git push -u origin master를 입력해서 해당 레포지토리에 파일을 업로드했다. default Branch는 main인데 master에 push를 했기 때문에 새로운 branch가 생성되었다! 하지만 정작… dyno가 생성되지 않았다. 검색을 해보니 Aptfile, Procfile, 실행파일.py, requirements.txt, runtime.txt 네 가지의 파일이 추가적으로 필요하다고 한다. Aptfile을 제외한 다른 파일들은 전부 있기 때문에 Aptfile만 추가적으로 생성하면 된다. 파일 이름은 Aptfile, 내용은 git이라고 적으면 끝.2.오후 1시에 출력되어야 하는 데이터가 오후 10시에 출력되는 오류가 발생했다. 다시 한 번 새롭게 App을 생성하면서 타임존을 서울에 맞추는 걸 까먹었다. cmd 창에서 Heroku login을 진행한 다음(이걸 Heroku CLI라고 한다.) 다음의 코드를 입력해주면 된다.heroku config:add TZ=&quot;Asia/Seoul&quot; --app=[ApplicationName]참고로 대괄호는 삭제하고 본인의 것을 입력할 것.3.여유가 되면 Token 값을 config vars로 설정하는 것 역시 진행할 것이다. 보안은 언제나 중요하니까." }, { "title": "220330", "url": "/posts/220330TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-31 07:30:00 +0900", "snippet": "1.tweet.entities[&#39;user_mentions&#39;][i][&#39;id&#39;] != int(idNum):TypeError: list indices must be integers or slices, not dictHeroku에 수정한 토이 프로젝트 배포를 하고 출근을 했다. 기분 좋게 로그를 확인했는데 저런 오류가 출력되어 있었다. 외부라서 코드를 확인할 수는 없지만, tweet.entities[‘user_mentions’][i][‘id’]라는 값이 dict인 반면 idNum은 Integer 값이라서 발생한 오류가 아닐까 싶다. 그런데 document를 확인해보면 딱히 dict로 출력될만한 부분이 없어서 헷갈린다. 🤔 user_mentions가 안에 dict값이 담긴 list 형태이긴 한데 이 부분은 전부 iteration을 사용해 접근을 했기 때문에… 결국 집 가서 직접 확인하는 방법 밖에 없을 것 같다.2.집에 가야만 코드를 확인할 수 있다니 너무 불편하다. github와 heroku를 반드시 연동하고 말겠다.3.구글 스프레드 시트에서 ReadRequestsPerMinutePerUser 에러가 발생했었다. 구글 스프레드시트의 경우 1분에 60회의 읽기 제한이 있기 때문에 그 이상의 리퀘스트 제한은 별도로 구글에 요청을 해야한다. Google Cloud Platform Console에 들어간다. IAM 및 관리자에서 할당량을 클릭한다. Google Sheets Api에서 Read requests per minute per user를 체크한다. 상단의 할당량 수정을 클릭한다. 희망하는 할당량 한도와 사유를 영문으로 작성해 전송한다.평균 이틀이 걸리지만 급한 경우 자동으로 오는 메일에 급하다고 회사을 보내면 하루도 안 돼서 처리를 해준다. 기존 한도는 60이었고, 600으로 늘려달라고 요청을 했는데 최종적으로 300의 할당량 한도를 받았다. 다행히 300으로도 별 무리 없이 돌아가서 만족한다." }, { "title": "220328", "url": "/posts/220328TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-29 07:30:00 +0900", "snippet": "1.Heroku에서 파이썬 파일을 돌렸는데, 하나는 성공하고 하나는 실패했다. 정해진 시간마다 스크립트를 출력하는 파이썬 파일에서 두개는 성공했는데, 하나에서 오류가 발생한 것 같다. 오류 분석을 한 다음 기능을 조금 더 보완할까 생각 중이다. 사용 설명서 같은 문서도 작성해야 하고. 아, 특정 사람에게만 반응하는 기능도 고민 중인데 이 특정 사람을 다수로 설정해서 기능을 구현할 예정이다.2.회사 내에서 RD를 사용해 틈나는대로 독학 중이다. 나름 간편한 것 같다.3.오늘은 보고서를 작성하느라 코드에 신경을 많이 못 썼다… 이번에 작업 중인 프로젝트는 저장 버튼을 누르면 눌렀을 때의 시간을 테이블에 저장해야하는데, 어느 테이블에 저장하는 게 가장 접근이 수월할지 고민 중이다." }, { "title": "220327", "url": "/posts/220327TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-28 07:30:00 +0900", "snippet": "1.Heroku에 push를 하는 형태였는데 github와 연동해보는 걸 고민 중이다. 아직 익숙하지 않아서… 시간이 나면 시도해볼 예정.2.파이썬에서 format을 이용하면 문자열을 간단하게 치환할 수 있는데 어쩌다보니 format을 사용하지 않고 구현을 했다. 의외로 정규식 사용할 일이 많아서 다시 한 번 복습을 했다.3.이미지를 두개만 출력할 수 있게하다가 네개를 출력할 수 있도록 코드를 바꾸려고 했는데 에러가 났다. 되게 사소한 변경이라 생각했는데 코드는 알다가도 모르겠다.4.누구든 본인이 원하는 지역의 날씨를 원하는 시간대에 알림 받을 수 있게 설정했다. 무언가를 해내는 건 언제나 기분이 좋다." }, { "title": "220326", "url": "/posts/220326TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-27 08:30:00 +0900", "snippet": "1.기존 토이프로젝트는 작동하는 시간을 설정하면 월화수목금토일 전부 동일한 시간에 작동하도록 설계했었다. 오늘은 월화수목금토일 작동하는 시간을 이용자가 개별적으로 설정할 수 있도록 변경했다.또한 기존 코드는 40초 단위로 데이터를 갱신했었는데 이 경우 과다한 request로 가끔 에러가 발생했다. 그대로 둬도 큰 문제는 없지만 3분 간격으로 데이터를 갱신하게끔 설정했다.키워드에 반응하는 스크립트만 이미지와 변수값을 사용할 수 있게 설정했는데, 주기적으로 스크립트를 송출할 경우에도 이미지와 변수값을 사용할 수 있게 만들 예정이다.또한 스크립트 길이가 지나치게 길 경우 자동으로 분할해서 출력하는 기능도 만들고 싶다. 하고 싶은 건 많은데 시간이 너무 빨리 간다…" }, { "title": "220325", "url": "/posts/220325TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-26 06:00:00 +0900", "snippet": "1.오늘은 반차를 사용했다보니 집에서 토이 프로젝트에 좀 더 집중했다. DB를 전반적으로 뜯어고치면서 코드도 많은 부분을 수정했다. 그러니 오히려 오류가 많이 보여서 처음부터 새로 코딩하는 게 낫지 않을까 싶을 정도. 모듈화를 열심히 했는데도 이런다. 이래서 대부분의 회사들이 폭포수 모델로 작업하는 걸까. 이번주 내에 마무리 짓고 싶었는데 가능할지 모르겠다… … 사용자의 행동 제약을 보다 완화시키고 싶은데, 그 선을 생각하는 게 어려운 것 같다.2.토이 프로젝트를 나중에 웹사이트로 구현하는 것도 고려하고 있는데, 이때 백엔드 부분을 플라스크로 작업할지 다른 걸로 작업할지 고민이다. 무얼하건 새로 배워야한다는 건 변함이 없지만요.3.알고리즘을 안하다 보니 많이 까먹었다. 프로젝트 마무리하는대로 다시 시작해야겠다." }, { "title": "220324", "url": "/posts/220324TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-25 00:00:00 +0900", "snippet": "1.svn에서 업데이트를 진행하던 도중 Checksum mismatch for while updating 오류가 발생했다. 인터넷을 검색해보았고, 해결방안은 두 가지가 있었다.1) 프로젝트 Cleanup해당하는 프로젝트를 우클릭한 다음, Team의 Cleanup을 누른다. 불행히도 작동하지 않았다.2) 폴더 삭제해당 파일이 위치한 폴더를 삭제한다.(미리 백업하는 것을 추천) Team의 Cleanup을 실행한 다음 다시 한 번 업데이트를 실행한다. 다행히 정상 작동을 했다.2.배포한 코드에서 오류가 발생했다. 정확히는 추가적인 요구사항. 요구한 부분만 들어주는 게 아니라, 해당 요구사항을 받아들이고 수정했을 때 어디까지 영향을 미칠지, 어떤 요구사항이 추가적으로 들어올지까지 생각하는 게 중요한 것 같다.가령 조회하는 분야를 하나 더 추가한다는 요구사항이 있으면, 단순히 거기서 끝나는 게 아니라 조회한 데이터를 출력할 수 있게 되어있는지, 그렇다면 수정한 부분 역시 출력이 가능한지를 확인하는 것들.3.토이 프로젝트를 조만간 베타 테스트할 생각인데 설레면서 걱정도 된다. 의외로 신경쓰였던 건 어떻게 해야 데이터를 최대한 중복없이 효율적으로 조회하고 가져올 수 있는지.처음에는 별 생각이 없었는데, 자주 조회할 수록 서버를 다녀오는 대기 시간 때문에 작동하기까지도 오래 걸리고 무엇보다 청구 비용이 발생할 확률이 높아져서(ㅋㅋ) DB를 몇 번이나 뜯어고쳤는지 모르겠다. 물론 더 뜯어고치게 될 것이다. 기능은 늘어나는데 데이터를 조회하는 빈도수는 유지를 해야하니까.잘 됐으면 좋겠다." }, { "title": "220323", "url": "/posts/220323TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-23 23:00:00 +0900", "snippet": "1.오늘은 유효성 검사 부분을 개선했다. 기존에는 데이터를 저장하기 전 유효성 검사 함수를 호출한 뒤, 위배되면 오류 메시지를 출력하되 저장을 진행하는 형태였다. 개 중 특정 규칙은 위배가 될 경우 저장을 하지 못하도록 기능 개선을 해야했다. 따라서 유효성 검사에서 특정 규칙을 위배할 경우, -1을 리턴하도록 했다. 그리고 함수를 호출한 뒤의 값이 -1이면 저장 기능을 수행하지 않도록 설정했다.2.개인적으로 진행하는 토이 프로젝트가 있는데 생각보다 고려해야할 것들이 많다. 데이터베이스가 있다면 키워드 함수명 키워드A Input Text에 키워드A가 존재할 경우 수행하는 함수 키워드B Input Text에 키워드B가 존재할 경우 수행하는 함수 null Input Text에 어느 키워드도 존재하지 않을 경우 수행하는 함수 이러한 형태로 구성되어 있는데, 현재 프로젝트에서는 어떤 함수도 수행하지 않고 있다. 아마 키워드 값이 null인 게 원인인 것 같은데, 오류 원인을 자세히 분석해봐야겠다.3.무언가를 수정할 때, 자신을 믿지 말고 가급적 백업본을 만들어 둘 것." }, { "title": "220322", "url": "/posts/220322TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2022-03-22 11:00:00 +0900", "snippet": " 회사에 입사한지 어느덧 2달이 지났다. 부장님께서 작업 일지를 작성해보는 게 어떠냐고 충고를 하셨고, 간단하게나마 적어보려고 한다.사용자의 요구사항을 명확하게 이해하는 것은 항상 어렵다. 같은 문장을 두고도 사람들은 각각의 방식으로 이해하기 때문에 개발을 하다 보면 소통에서 문제가 생길 때도 더러 있었다. 모호한 부분은 검토하는 과정에서 체크를 하고, 확인을 하는 게 작업 시간을 훨씬 줄였다. 기존에 코드를 작성할 때 모듈화를 하고, 해당 코드 관련해서 기록을 해두는 게 확실히 유용한 것 같다. 이전에 작업을 할 때 검색 기능을 구현한 적이 있는데, 이번에 비슷한 걸 구현할 때 이전에 작성했던 코드를 참고하는 게 훨씬 도움이 됐다. 검색 기능을 구현할 때 고려한 것들 그리드나 테이블 형태로 데이터가 주어졌을 때, 해당 단어를 포함하고 있는 데이터만 출력하게 할 것인지 / Ctrl+F처럼 커서를 이동시키는 형태로 구현할 것인지 검색을 할 때, 커서의 위치는 항상 현재 위치 + 1을 해야한다. 그렇지 않으면 커서가 이동하지 않는다 데이터를 전부 조회했을 때, 단어를 찾지 못했을 경우 처리를 어떻게 할 것인지(-&amp;gt; 이 경우, 위치를 맨처음으로 초기화 시켰다.) 커서를 이동시키는 형태로 검색을 진행할 경우, 현재 위치한 커서를 시작점으로 검색을 할 건지, 커서 위치를 처음으로 초기화한 다음 검색을 할 것인지 iteration 안에서 특정 조건을 만족하는 데이터가 하나라도 있는지, 아예 존재하지 않는지를 확인해야할 때가 있다. flag를 사용하지 않고 보다 나은 방식으로 코드를 작성할 수는 없을까? -&amp;gt; for문을 순회할 때, 조건을 만족하면 break를 사용한다. 그리고 i라는 변수가 최대값인지를 확인한다 모듈화 최고" }, { "title": "LeetCode_Maximum Nesting Depth of the Parentheses", "url": "/posts/LeetCode_Maximum-Nesting-Depth-of-the-Parentheses/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, Stack", "date": "2021-11-25 21:28:00 +0900", "snippet": "Maximum Nesting Depth of the ParenthesesA string is a valid parentheses string (denoted VPS) if it meets one of the following: It is an empty string &quot;&quot;, or a single character not equal to &quot;(&quot; or &quot;)&quot;, It can be written as AB (A concatenated with B), where A and B are VPS’s, or It can be written as (A), where A is a VPS.We can similarly define the nesting depth depth(S) of any VPS S as follows: depth(&quot;&quot;) = 0 depth(C) = 0, where C is a string with a single character not equal to &quot;(&quot; or &quot;)&quot;. depth(A + B) = max(depth(A), depth(B)), where A and B are VPS’s. depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A), where A is a VPS.For example, &quot;&quot;, &quot;()()&quot;, and &quot;()(()())&quot; are VPS’s (with nesting depths 0, 1, and 2), and &quot;)(&quot; and &quot;(()&quot; are not VPS’s.Given a VPS represented as string s, return the nesting depth of s. Input: s = “(1+(2*3)+((8)/4))+1”Output: 3 Input: s = “(1)+((2))+(((3)))”Output: 3 Input: s = “1+(2*3)/(2-1)”Output: 1 Input: s = “1”Output: 0 과정 Time: O(n)Space: O(1)코드var maxDepth = function(s) { let max = 0; let sCnt = 0; for(let i = 0; i&amp;lt;s.length; i++){ if(s[i]===&quot;(&quot;){ sCnt++; max = Math.max(sCnt, max); } if(s[i]===&quot;)&quot;){ sCnt--; } } return max};Submission Detail Runtime: 86 ms Your runtime beats 26.46 % of javascript submissions. Memory Usage: 38.7 MB Your memory usage beats 86.89 % of javascript submissions.후기 처음에는 Stack의 pop과 push를 이용해서 문제를 풀었다. 이후, 공간 복잡도를 고려해 Stack 대신 sCount라는 변수를 사용해서 문제를 풀었다." }, { "title": "JavaScript_객체", "url": "/posts/JavaScript_%EA%B0%9D%EC%B2%B4/", "categories": "Study, JavaScript", "tags": "JavaScript, Inflearn", "date": "2021-11-23 21:42:00 +0900", "snippet": "객체의 소개와 문법 영어로는 object. 연관된 데이터들을 담아내는 일종의 그릇이다. 자바스크립트에서 배열과 유사한 역할을 한다. 객체와 배열의 차이점 인덱스가 자동으로 정해지는 배열과 달리, 객체는 인덱스의 값으로 숫자가 아닌 문자나 원하는 데이터를 사용할 수 있다. 다른 언어에서는 연관배열 또는 맵, 딕셔너리라는 데이터 타입이 객체에 해당한다. 객체는 객체 지향이라고 하는 프로그램 패러다임과 밀접한 연관이 있다. 객체를 만드는 방법 ```var grades = {}; // var grades = new Object();grades[‘egoing’] = 10;grades[‘k8805’] = 6;grades[‘sorialgi’] = 80; console.log(grades[‘k8805’];// console.log(grades[‘k88’+’05’];// console.log(grades.k8805)// console.log(grades.’k88’+’05’)는 SyntaxError 발생### 객체와 반복문- 배열은 저장된 데이터들이 순서를 갖고 있다. - 먼저 들어간 데이터와 나중에 넣은 데이터가 기록되어 있다. - 해당 상태가 내부적으로 유지되므로, 넣은 순서대로 꺼내는 것이 가능하다.- 객체 안에 저장된 값은 순서가 없다. Key와 Value가 한쌍으로 존재한다.- 객체의 key를 가져올 때 for in문을 사용한다. (배열에서도 동일하게 적용되며, 이 경우는 인덱스 값을 출력)var arr = [‘a’, ‘b’, ‘c’];for(var name in arr){ console.log(name);} // 0 1 2, 인덱스 값을 출력### 객체 지향 프로그래밍var grades = { ‘list’: {‘egoing’: 10, ‘k8805’: 6, ‘sorialgi’: 80}, ‘show’ : function(){ // 변수가 가리키는 그릇에 담겨있는 key 값을 하나씩 가져온다. // 이 key 값을 name에 담는다. for(var name in this.list){ document.write(“&amp;lt;li&amp;gt;name”+’:’+this.list[name]+”&amp;lt;/li&amp;gt;”); } }};grades.show(); // grades‘show’;``` graders라는 객체 안 list라는 키값은 다시 객체를 가질 수 있다. 객체 내의 value는 객체거나 함수일 수도 있다. grades라는 객체에 접근할 때는 grades[‘list’], grades[‘list’][‘egoing’], grades‘show’를 사용. this는 자바스크립트에 약속된 변수로 함수가 속해있는 객체를 가리킨다. this는 함수를 어떻게 생성했냐에 따라 달라지지만, 여기서 this는 함수를 소유하고 있는 객체를 의미한다. this.list를 하면 이 객체가 갖고 있는 list라는 key 값이 가리키는 객체를 가리킨다. console.log(this.list); 하면 list가 가리키는 객체가 출력할 수 있으며, alert보다 condsole.log를 사용하는 것이 데이터를 확인할 때 더 편리하다. 연관되어 있는 값과 처리를 하나의 그릇 안에 모아서 grouping 해놓은 프로그래밍 기법 스타일을 객체 지향 프로그래밍이라고 한다." }, { "title": "JavaScript_배열", "url": "/posts/JavaScript_%EB%B0%B0%EC%97%B4/", "categories": "Study, JavaScript", "tags": "JavaScript, Inflearn", "date": "2021-11-14 23:52:00 +0900", "snippet": "배열 배열이란 연관된 데이터를 모아 통으로 관리하기 위해 사용하는 데이터 타입이다. 변수 : 데이터를 담는 그릇으로, 하나의 그릇에 하나의 데이터만 넣을 수 있다. 배열 : 역시 데이터를 담는 그릇이나, 하나의 그릇에 여러 데이터를 넣을 수 있다. 배열의 생성 대괄호([])는 배열을 만드는 기호. 대괄호 안에 데이터를 콤마(,)로 구분해서 내열하면 배열이 된다.var member = [&#39;egoing&#39;, &#39;k8805&#39;, &#39;sorialgi&#39;] // undefinedmember // [&quot;egoing&quot;, &quot;k8805&quot;, &quot;sorialgi&quot;] var member1 = “egoing”; 같은 식으로 변수에 하나의 값을 담았으나, 배열을 사용하면 하나의 변수 안에 여러 개의 데이터를 담을 수 있게 된다. 배열에 들어 있는 각각의 데이터를 원소(Element)라고 부른다.var member = [&#39;egoing&#39;, &#39;k8805&#39;, &#39;sorialgi&#39;]alert(member[0]);alert(member[1]);alert(member[2]); 배열 안 각각의 데이터를 원소라고 하며, 이들은 각각 고유한 식별자를 갖는다. 순서대로 0, 1, 2. 자바스크립트가 내부에서 자동으로 부여하는 값으로 한국어로 색인, 영어로는 인덱스라고 한다. 대괄호에 인덱스 번호를 전달하면 해당 인덱스에 해당하는 값을 반환한다. 프로그래밍은 숫자를 0부터 넘버링한다는 것을 잊지 말 것. 배열의 효용성 하나의 함수는 하나의 값만을 반환할 수 있기 때문에 배열을 사용하지 않으면 각각의 값을 반환하는 함수를 만들어야 한다. function get_members(){ return [&#39;egoing&#39;, &#39;k8805&#39;, &#39;sorialgi&#39;];}var members = get_members();document.write(members[0]);document.write(members[1]);document.write(members[2]); 배열은 연관되어 있는 정보를 한꺼번에 다룰 수 있게 하므로 프로그래밍에 있어 중요한 수단이다.배열의 사용function get_members(){ return [&#39;egoing&#39;, &#39;k8805&#39;, &#39;sorialgi&#39;];}var members = get_members();for(let i = 0; i&amp;lt;member.length; i++){ document.write(members[i].toUpperCase() + &quot;&amp;lt;br /&amp;gt;&quot;);}배열의 조작 - 추가var li = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];li.push(&#39;f&#39;);alert(li); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;];// concat 안에 담겨있는 배열과 li 배열을 연결// 하나의 배열로 만들어 return하고 그 값을 li에 담는다.li = li.concat([&#39;f&#39;, &#39;g&#39;]);var li = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];li.unshift(&#39;z&#39;);alert(li); // [&#39;z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]// 배열명.splice(index, howmany, element1, ..., elementN)// 배열의 중간에 추가// howmany : 해당 인덱스에서 제거되는 원소의 개수a.splice(1, 1, &#39;x&#39;, &#39;y&#39;); // [&#39;a&#39;, &#39;x&#39;, &#39;y&#39;, &#39;c&#39;]var myFish = [&#39;angel&#39;, &#39;clown&#39;, &#39;trumpet&#39;, &#39;sturgeon&#39;];var removed = myFish.splice(0, 2, &#39;parrot&#39;, &#39;anemone&#39;, &#39;blue&#39;);// [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;sturgeon&quot;]배열의 조작 - 제거, 정렬var li = [&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;];li.shift();alert(li); // [&#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;];li.pop();alert(li); // [&#39;d&#39;, &#39;b&#39;, &#39;c&#39;];li.sort(); // [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;];li.reverse(); // [&#39;d&#39;, &#39;c&#39;, &#39;b&#39;];" }, { "title": "LeetCode_Island Perimeter", "url": "/posts/LeetCode_Island-Perimeter/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, DFS", "date": "2021-11-13 21:02:00 +0900", "snippet": "Island PerimeterYou are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]Output: 16 Input: grid = [[1]]Output: 4 Input: grid = [[1,0]]Output: 4코드var islandPerimeter = function(grid) { var dx = [1, -1, 0, 0]; var dy = [0, 0, -1, 1]; let cnt = 0; for(let i =0; i&amp;lt;grid.length; i++){ for(let j = 0; j&amp;lt;grid[0].length; j++){ if(grid[i][j]!=1) continue; for(let k = 0; k&amp;lt;dx.length;k++){ if(i+dx[k]&amp;lt;0||j+dy[k]&amp;lt;0){ cnt++; continue; } if(i+dx[k]&amp;gt;grid.length-1||j+dy[k]&amp;gt;grid[0].length-1){ cnt++ continue; } if(grid[i+dx[k]][j+dy[k]]!=0) continue; cnt++; } } } return cnt;};Submission Detail Runtime: 160 ms Your runtime beats 92.67 % of javascript submissions. Memory Usage: 48 MB Your memory usage beats 81.80 % of javascript submissions.후기 2차원 배열에서 상하좌우 탐색을 진행할 때, x&amp;amp;y 이동 값을 배열 값으로 선언해두변 차후 탐색을 진행할 때 편리하다. 3번째 for문에서 3가지의 if문으로 조건을 분리했는데, 1번과 2번 if문은 가독성을 위해 분리했고, 3번 if문의 경우 1번과 2번 if문을 거치지 않은 상황에서 3번 if문에 진입하게 되면 out of index에 진입하게 되며 오류가 발생하기 때문에 별도로 분리를 했다." }, { "title": "LeetCode_Flood Fill", "url": "/posts/LeetCode_Flood-Fill/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, DFS", "date": "2021-11-12 23:25:00 +0900", "snippet": "Flood FillAn image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor.Return the modified image after performing the flood fill. Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]] Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2Output: [[2,2,2],[2,2,2]]과정 I: MxN Matrix, sr(Integer), sc(Integer), newColor(Integer)O: MxN MatrixC: 1 &amp;lt;= m, n &amp;lt;= 50, 0&amp;lt;= sr &amp;lt; m, 0&amp;lt;= sc &amp;lt; n DS: ArrayAlgo: DFS Pseudo:[[1,1,1],[1,&quot;1&quot;,0],[1,0,1]]// val = image[sr][sc] // 1[[1,1,1],[1,&quot;2&quot;,0],[1,0,1]][[1,&quot;1&quot;,1],[&quot;1&quot;,2,&quot;0&quot;],[1,&quot;0&quot;,1]][[&quot;1&quot;,2,&quot;1&quot;],[2,&quot;2&quot;,0],[1,0,1]][[&quot;2&quot;,2,&quot;2&quot;],[2,&quot;2&quot;,0],[1,0,1]][0, 0, 0][0, &quot;1&quot;, 1][0, 0, 0][0, &quot;1&quot;, &quot;1&quot;] Time: O(n) // 이미지 내의 픽셀에 접근Space: O(n) // DFS 호출 스택코드var floodFill = function(image, sr, sc, newColor) { let val = image[sr][sc]; if(val == newColor) return image; floodFillMatrix(sr, sc); function floodFillMatrix(sr, sc){ // out of boundary이거나, 값이 val과 일치하지 않으면 바로 return if(sr&amp;lt;0 || sc&amp;lt;0 || sr&amp;gt;image.length-1 || sc&amp;gt;image[0].length-1 || image[sr][sc] !== val){ return; } image[sr][sc] = newColor; floodFillMatrix(sr-1, sc); // 서쪽 floodFillMatrix(sr+1, sc); // 동쪽 floodFillMatrix(sr, sc-1); // 북쪽 floodFillMatrix(sr, sc+1); // 남쪽 // 상하좌우 탐색을 진행 } return image;};Submission Detail Runtime: 84 ms Your runtime beats 90.96 % of javascript submissions. Memory Usage: 41.3 MB Your memory usage beats 29.46 % of javascript submissions.후기 newColor 값과 image[sr][sc] 값이 동일할 때 무한루프가 발생한다. 이에 관한 Edge Case를 잘 숙지해야 한다. matrix에 접근할 때 out of boundary일 경우, Can not read property ‘?’ of defined 오류가 발생하니 이 부분을 유의해야 한다." }, { "title": "JavaScript_함수", "url": "/posts/JavaScript_%ED%95%A8%EC%88%98/", "categories": "Study, JavaScript", "tags": "JavaScript, Inflearn", "date": "2021-11-11 22:46:00 +0900", "snippet": "함수함수(function)란 하나의 로직을 재실행 할 수 있도록 하는 것으로 코드의 재사용성을 높여준다.함수의 형식함수의 형식은 아래와 같다.function 함수명([인자...[,인자]){ 코드 return 반환값}함수의 정의와 호출&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; function numbering(){ // 함수 정의 i = 0; while(i&amp;lt;10){ document.write(i+&quot;&amp;lt;br /&amp;gt;&quot;); i += 1; } } var a = 1; // 변수 정의 alert(a); // 변수 호출 numbering(); // 함수 호출, 괄호가 없다면 JavaScript는 변수로 인식한다. numbering(); // numbering() 내부의 코드 실행 numbering(); numbering(); numbering(); numbering(); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;함수의 효용성&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; function numbering(){ // 함수 정의 i = 0; while(i&amp;lt;10){ document.write(i+&quot;&amp;lt;br /&amp;gt;&quot;); i += 1; } } for(var i=0; i &amp;lt; 1000; i++){ numbering(); // 함수를 1000번 실행 } &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 반복문 : 함수와 마찬가지로 어떠한 로직을 반복적으로 재사용할 때 사용. 하지만 함수와 비교했을 때 함수와 반복문이 갖고 있는 효용은 다르다. 반복문은 기계적으로 일정한 반복을 그 자리에서 실행할 때 의미가 있다. 함수 : 반복적으로 실행되는 로직이 여러가지 맥락에서 반복적으로 쓰이는 경우 의미가 있다. 어디든 호출한 곳에서 실행이 가능하다. 재사용성의 핵심은 동일한 코드가 있을 때 해당 코드를 여러 곳에서 사용할 수 있는 형태로 만드는 것. 좋은 부품을 만드는 것이 재사용성의 목표다. 재사용성이 높아지면 함수의 내용(코드)을 수정, 변경, 개선해 문제 해결을 할 경우, 해당 함수를 사용하는 모든 곳에서 반영이 된다다. 이러한 특성을 유지 보수(maintenance)가 용이하다라고 한다. 그리고 코드의 가독성이 좋아진다. 재사용성, 유지보수의 용이, 가독성은 비례 관계이다. 프로그래밍이 발전하는데 있어 가장 핵심적인 개념으로, 이것들이 잘 만들어져 있지 않다면 수정하기 힘든 프로그램이 되고, 쉽게 버그가 발생해 심각한 문제를 야기할 수 있다. 따라서 프로그램에서 이러한 것들은 매우 중요하고, 프로그램의 발전 방향성은 이 세가지에 있다고 할 수 있다. 객체 지향 등 문법적인 것들을 만났을 때 이런 것들을 어떻게 극복하는지를 중점적으로 봐야 한다.함수의 입력 서양권에서 function은 기능, 작용이라는 의미. 동양권에서 함수의 함은 상자 함이다. 상자 함을 사용하게 된 동기로는 “영어에서 function이라 한 것을 함수라는 소리로 옮길 수 있다. (음역)”라는 주장과, 함수라는 상자가 있고, 그 상자 안에 값을 넣으면 다른 결과가 출력되는 상자라는, funcion의 본질적인 의미를 반영한 창조적인 단어라는 주장도 있다. 입력에 따라 출력이 달라진다. (Function Machine)입력과 출력&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; function get_member1(){ return &#39;egoing&#39;; // 출력 return &#39;leezche&#39;; return &#39;graphittie&#39;; } function get_member2(){ return &#39;k8805&#39;; } alert(get_member1()); alert(get_member2()); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 첫번째 return 뒤에 나오는 코드는 동작하지 않는다. 출력은 내부적으로 return을 통해 출력된다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; // arg는 매개**변수**(parameter), 값을 받는 변수. function get_argument(arg1, arg2){ return arg1 + arg2; // return은 출력 } // arg1 = 10, 이 때 arg1로 전송된 값인 10을 인자(argument)라고 부른다. 값 자체는 인자다. alert(get_argument(10, 20)); alert(get_argument(20, 30)); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 여러개의 입력값을 받을 수 있지만 return값은 한 개만 가능하다.다양한 정의 방법&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; var numbering = function(){ // numbering이라는 변수가 함수를 갖게 된 것. i = 0; while(i &amp;lt; 10){ document.write(i); i += 1; } } /* function numbering(){ i = 0; while(i &amp;lt; 10){ document.write(i); i += 1; } } */ // 이렇게 선언하면 상단 두 종류의 코드는 동일하다. numbering(); // 함수를 정의한 후 괄호로 묶었다. // 이후 함수를 호출할 때 사용하는 기호 ();를 사용, // 따라서 함수를 정의하는 것과 정의된 함수를 호출하는 것이 한 문장에 들어간다. // 이를 익명함수라 한다. 이름이 없고 바로 실행되는 함수다. // 일회성으로 호출할 때 이런 technic을 사용한다. // 요약 : 정의와 호출이 동시에 가능한 함수. (function(){ i = 0; while(i &amp;lt; 10){ document.write(i); i += 1; } })(); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 함수는 코드의 재활용성을 높여준다. 자바스크립트를 함수영 언어라고 표현하기도 한다. 그 언어를 규정짓는 특징으로 함수를 사용할 정도로 자바스크립트는 함수가 차지하는 위상이 높다." }, { "title": "LeetCode_Increasing Order Search Tree", "url": "/posts/LeetCode_Increasing-Order-Search-Tree/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, DFS", "date": "2021-11-10 23:09:00 +0900", "snippet": "Increasing Order Search TreeGiven the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] Input: root = [5,1,7]Output: [1,null,5,null,7]과정 I: TreeO: TreeC: 0 &amp;lt;= Node.val &amp;lt;= 1000 DS: TreeAlgo: Recursion Time: O(N)Space: O(H)코드var increasingBST = function(root) { let ansNode = new TreeNode(0); let cur = ansNode; inorder(root); function inorder(node){ if(node === null) return; inorder(node.left); // L node.left = null; cur.right = node; // U cur = node; inorder(node.right); // R } return ansNode.right;};Submission Detail Runtime: 76 ms Your runtime beats 73.31 % of javascript submissions. Memory Usage: 40.1 MB Your memory usage beats 63.80 % of javascript submissions.후기 Recursion을 통해 가장 왼쪽에 위치한 노드에 접근한다. 그리고 해당 노드가 null 값이면 종료하고 부모 노드로 올라온다. 그리고 부모 노드의 Left 노드를 null 값으로 변경 후 현재 노드를 새로 만든 Tree에 값을 추가한다. 그리고 오른쪽을 탐색한다. 그 다음 다시 부모 노드로 올라온다. 위와 같이 Bottom-up 접근 방식을 통해 문제를 풀 수 있다. Space Complexity는 기본적으로 O(H)이지만, 최악의 경우는 O(N)이다. 1 / \\2 5 / \\ / \\ 3 4 6 7 1을 Stack에 추가. O(1) 1을 제거하고 2와 5를 추가. O(2) 2를 제거하고 3과 4를 추가. O(3) 3을 제거. O(2) 4를 제거. O(1) 5를 제거하고 6과 7을 추가. O(2) 6을 제거. O(1) 7을 제거. O(0) 이 때 최악의 Space는 O(3)으로 곧 높이와 동일한 것을 알 수 있다. " }, { "title": "LeetCode_Middle of the Linked List", "url": "/posts/LeetCode_Middle-of-the-Linked-List/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, Linked List, Two Pointers", "date": "2021-11-09 00:32:00 +0900", "snippet": "Middle of the Linked ListGiven the head of a singly linked list, return the middle node of the linked list.If there are two middle nodes, return the second middle node. Input: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3. Input: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.과정 I: Linked ListO: the middle node of the Linked ListC: 1&amp;lt;= the number of nodes &amp;lt;= 100, 1 &amp;lt;= node.val &amp;lt;= 100E: if head is null DS: Linked ListAlgo: Iteration Pseudo: 1. s,f[1, 2, 3, 4, 5]2. s f[1, 2, 3, 4, 5]3. f.next is null s f[1, 2, 3, 4, 5]4. s,f[1, 2, 3, 4, 5, 6]5. s f[1, 2, 3, 4, 5, 6]6. s f[1, 2, 3, 4, 5, 6]7. f is null s f[1, 2, 3, 4, 5, 6] Time: O(N)Space: O(1)코드var middleNode = function(head) { let first = head; // head를 가리키는 포인터. let second = head; while(first.next!==null&amp;amp;&amp;amp;first!==null){ first = first.next.next; second = second.next; } return(second);};Submission Detail Runtime: 68 ms Your runtime beats 89.83 % of javascript submissions. Memory Usage: 39.1 MB Your memory usage beats 12.57 % of javascript submissions.후기 절반의 위치에 도달하는 방법을 생각해낸다면 쉽게 풀 수 있다. A가 두 칸을 갈 때 B는 한 칸을 간다. 이 때 A가 목적지에 도달했을 때 B는 당연히 목적지의 절반 거리만큼 도달해 있다. 라는 걸 떠올리면 된다." }, { "title": "LeetCode_Shortest Distance to a Character", "url": "/posts/LeetCode_Shortest-Distance-to-a-Character/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, Array, Two Pointers, String, 100%", "date": "2021-11-08 21:22:00 +0900", "snippet": "Shortest Distance to a CharacterGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.The distance between two indices i and j is abs(i - j), where abs is the absolute value function.과정 I: String, characterO: Array of IntegersC: 1&amp;lt;=s.length&amp;lt;=10^4, s[i] and c are lowercase Eng lettersE: s is null, s.length is 0 DS: ArrayAlgo: Two Pointer Pseudo:첫번째 for문 “l” o v e l e e t c o d eleft = 1 l “o” v e l e e t c o d eleft = 2 l o “v” e l e e t c o d eleft = 3 l o v “e” l e e t c o d earr = [3, 2, 1, Inf]left = 0 l o v e “l” e e t c o d earr = [3, 2, 1, Inf]left = 1 l o v e l “e” e t c o d earr = [3, 2, 1, Inf, 1, Inf]left = 0 두번째 for문 “l” o v e l e e t c o d eright = -1arr = [3, 2, 1, Inf, 1, Inf, …] l “o” v e l e e t c o d eright = -1arr = [3, 2, 1, Inf, 1, Inf, …] l o “v” e l e e t c o d eright = -1arr = [3, 2, 1, Inf, 1, Inf, …] l o v “e” l e e t c o d eright = 0arr = [3, 2, 1, 0, 1, Inf, …] l o v e “l” e e t c o d eright = 1arr = [3, 2, 1, 0, 1, Inf, …] l o v e l “e” e t c o d eright = 0arr = [3, 2, 1, 0, 1, 0, …] Time: O(n)Space: O(n)코드var shortestToChar = function(s, c) { let left = 0; let right = -1; let arr = new Array(s.length).fill(Infinity); for(let i = 0; i&amp;lt;s.length;i++){ if(s[i]!==c){ left++; continue; } while(left&amp;gt;0){ arr[i-left] = left; left--; } } for(let i = 0; i&amp;lt;s.length;i++){ if(s[i]===c) right = 0; if(right&amp;lt;0) continue; arr[i] = Math.min(right, arr[i]); right++; } return arr;};Submission Detail Runtime: 68 ms Your runtime beats 100.00 % of javascript submissions. Memory Usage: 40.8 MB Your memory usage beats 71.78 % of javascript submissions.후기 Runtime 100%가 나왔다. 아직 갈 길이 멀긴 해도 기분이 좋다! 아마도 두번째 for문을 돌 때, 초기에 c를 만나기 전까지 continue문을 사용해 배열 값을 갱신하는 부분을 건너 뛰어서 빠른 속도가 나온 게 아닐까. 추측해본다. 처음에는 for문을 한 번만 돌아서 문제를 풀려했는데, for문의 arr[i-left]에서 이전값을 새롭게 덮어씌우다보니 Math.min으로 부여했던 기존 값이 사라지게 되면서 오류가 난다. for문을 두 번 사용하는 것이 최선의 방법인 것 같다." }, { "title": "LeetCode_Remove All Adjacent Duplicates In String", "url": "/posts/LeetCode_Remove-All-Adjacent-Duplicates-In-String/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, Stack", "date": "2021-11-07 23:39:00 +0900", "snippet": "Remove All Adjacent Duplicates In String - LeetCodeYou are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.We repeatedly make duplicate removals on s until we no longer can.Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.과정 I: String(문자열)O: String(문자열)C: 1&amp;lt;=s.length&amp;lt;=10^5, s is always lowercase Englich letters.E: If s.length is 0 or s is null, return -1 DS: StackAlgo: Iteration Pseudo:for문을 사용해 글자 단위로 Stack에 삽입.이 때, 방금 Stack에 넣은 글자와, 현재 글자가 같을 경우, Stack에 삽입한 글자를 다시 빼낸다.(pop) Time: O(N)Space: O(N)코드var removeDuplicates = function(s) { // Input abcdefg (n) let strArr = []; // strArr에 내가 많은 데이터를 넣을 수록 space를 많이 차지한다 for(let i =0; i&amp;lt;s.length; i++){ if(s[i]!==strArr[strArr.length-1]){ strArr.push(s[i]); continue; } strArr.pop(); } // 배열을 하나의 문자열로 만들어서 반환 return strArr.join(&quot;&quot;); };Submission Detail Runtime: 92 ms Your runtime beats 77.00 % of javascript submissions. Memory Usage: 48.3 MB Your memory usage beats 38.01 % of javascript submissions.후기 Stack을 알고 있다면 어렵지 않게 풀 수 있는 문제다." }, { "title": "211107_English", "url": "/posts/English/", "categories": "Blogging, English", "tags": "English", "date": "2021-11-07 18:02:00 +0900", "snippet": "실시간으로 대화하니 문법이 사정없이 틀린다. 😥 약 10일을 대화하는 동안 상대가 알려줬던 문법 오류를 복습할 겸 적어본다.1.I submit that safely.→ I submitted that safely.→ 과거형이기 때문2.I’ll skip it for a second.→ I’ll skip this for now.3.I am using translator together.→ I am using a translator.4.Do you prepare well for the test?→ Did you finish preparing for the test?5.I’m preparing for a web developer.→ I’m preparing to be a web developer.6.I was also interested in Computer.→ I was also interested in computers→ 하나의 컴퓨터에 관심을 갖고 있는 것이 아니기 때문.7.Which subject do you learn now?→ Which subject are you learning about now?→ 링크 참조8.I take modules about JSP.→ I am taking about modules about JSP→ 지금도 modules를 수강 중이기 때문.9.It got broken so I threw it away.→ It was broken so I threw it away.→ got을 사용할 때 (내가/다른 사람)이 깼다는 느낌이 있다. (__지다, 변화가 있다.) 그러나 was를 사용할 시, 어떻게 고장났는지는 알 수 없지만 지금 고장났다의 느낌이 있다. (__였다. 단순 fact.)10.I’m in 4th grade.→ I’m in year 4.11.I’m most curious about is how Ethel was interested in Korea.→ I’m most curious about is how Ethel got interested in Korea.12.I had to study separately.→ I had to study on my own.13.I tend to listen to it all over.→ I tend to listen to everything.14.I have pictures about A.→ I have picture of A.→ I am thinking of you. 는 “너를 생각해”지만, I am thinking about you.는 “너에 관해 생각해”다.15.How do I beat the genius who tries and enjoys computer?→ How do I beat the genius who tries and enjoys computers?→ 컴퓨터는 하나의 주제이기 때문에 plural form을 사용한다.16.I started to like Seunghee during the Nonstop era.→ Nonstop 활동 시기에 무대를 보고 나서 승희를 좋아하게 되었다는 의미.After seeing Seunghee perform (the song) “Nonstop”, I started to like her / I started to like Seunghee after seeing her perform (the song) “Nonstop”→ “하나의” 무대를 보고 나서 승희를 좋아하게 되었다는 의미.17.When they sang Dolphin, every Korean likes that song and dance about dolphin.→ When they sang Dolphin, every Korean liked that song and danced to it.→ 과거이므로 liked를 사용, Dolphin을 앞에서 이미 언급했으므로 it이나 the song으로 대체.18.We can pass the college with college entrance exam scores. → What’s the format of the assessments in Singapore?→ Test questions는 하나의 시험에서 물어본 질문이므로 assessments가 적절하다.19.We can pass the college with hcollege entrance exam scores.→ We can get into college with hcollege entrance exam scores.→ pass는 모든 사람이 합격한다는 의미를 지니고 있다.20.You must go to high school or passed the exam.→ You must go to high school or pass the exam.→ 사실은 언제나 present tense로 말한다.21.Kaya toast is boom in Korea these days.→ Kaya toast is booming in Korea these days." }, { "title": "211107", "url": "/posts/211107TIL/", "categories": "Blogging, TIL", "tags": "daily, til", "date": "2021-11-07 02:00:00 +0900", "snippet": "깃 블로그가 생각보다 어렵다. 본래 리액트 기반인 Gatsby를 사용하여 테마를 만들고 싶었지만 영문을 알 수 없는 오류로 인해 3일을 헤메다 포기했다. (특히 Icarus 테마가 취향이었는데 그게 개인적으로 아쉽다…)11월 4일인가, 겨우 깃 블로그를 만들었는데 글 제목을 변경할 시 제대로 반영이 되지 않는 등 자잘한 오류들이 생겼다. 캐시 문제인가 싶어 개발자 모드에서 Disable Cache 설정도 해보았는데 생각만큼 잘 안 풀렸다. 아직 갈 길이 멀다." }, { "title": "BinarySearch_Strictly Increasing or Strictly", "url": "/posts/BinarySearch_Strictly-Increasing-or-Strictly/", "categories": "Algorithm, BinarySearch", "tags": "BinarySearch, easy, Array", "date": "2021-11-07 00:08:00 +0900", "snippet": "문제Given a list of integers nums, return whether the list is strictly increasing or strictly decreasing.코드class Solution { solve(nums) { let descending=true; let ascending=true; for(let i = 0; i&amp;lt;nums.length-1;i++){ if(nums[i]&amp;lt;=nums[i+1]) descending = false; if(nums[i]&amp;gt;=nums[i+1]) ascending = false; } return descending||ascending }}" }, { "title": "LeetCode_First Unique Character in a String", "url": "/posts/LeetCode_First-Unique-Character-in-a-String/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, String, Hash Table", "date": "2021-11-07 00:07:00 +0900", "snippet": "문제Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.코드var firstUniqChar = function(s) { let wordMap = new Map(); for(let i = 0; i&amp;lt;s.length; i++){ if(!wordMap.has(s[i])){ wordMap.set(s[i], 1); continue; } wordMap.set(s[i], 2); } for(let i = 0; i&amp;lt;s.length;i++){ if(wordMap.get(s[i])===1) return i; } return -1;};후기 Map에 존재하지 않는 새로운 문자가 들어올 시, Map에 해당 문자를 key, value는 1로 세팅한다. 그러나 이미 존재하는 문자가 입력될 경우 value를 2로 변경해서 한 번만 사용된 문자와 구분한다. 이후 for문을 돌면서 Map에서 value가 1인 key가 존재하는 경우, 인덱스인 i를 반환한다. 그러나 Map에 value가 1인 key가 없는 경우 for문을 다 순회할 것이다. 이 때는 -1을 return 한다. 코드를 작성하다 보면 if else문을 사용할지, continue문을 사용할지 고민이 될 때가 있다. 실무적인 면에서는 continue를 남발하는 것이 적절하지 않다는 이야기가 있으나, (애러 처리나 구조/기능 변경 시 다양한 실수를 유발할 수 있고, 자원 관리 측면의 문제가 있기 때문.) 적절한 선에서 사용 중이다. 이 부분은 기회가 되면 따로 정리해보는 것도 좋을 것 같다." }, { "title": "LeetCode_Roman to Integer", "url": "/posts/LeetCode_Roman-to-Integer/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, String, Hash Table", "date": "2021-11-05 04:08:00 +0900", "snippet": "문제Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer.코드var romanToInt = function(s) { const symbol = { I:1, V:5, X:10, L:50, C:100, D:500, M:1000 }; let result = 0; for(let i = 0; i&amp;lt;s.length; i++){ if(symbol[s[i]]&amp;lt;symbol[s[i+1]]){ result -= symbol[s[i]] continue; } result += symbol[s[i]] } return result;};후기유의해야 할 조건은 언제 뺄셈이 되는가. 다시 말해, IV는 4이고, VI는 6이라는 값이 되는 기준이 무엇인가. 답은 첫번째 글자의 값이 두번째 글자의 값보다 작을 때, 첫번째 글자의 값에 -를 부여한다는 것이다. 먼저 Hash Table을 사용해서 글자(I, V, X…)에 해당하는 값을 부여한다. 이후 iteration을 통해 모든 글자를 순회하며, 글자에 부합하는 값을 가져오고 조건에 따라 값을 더하거나 빼는 형태로 문제를 풀 수 있다." }, { "title": "LeetCode_Longest Common Prefix", "url": "/posts/LeetCode_Longest-Common-Prefix/", "categories": "Algorithm, LeetCode", "tags": "LeetCode, easy, String", "date": "2021-11-04 15:35:00 +0900", "snippet": "문제Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string &quot;&quot;.코드var longestCommonPrefix = function(strs) { let commonPrefix = strs[0]; for(let i =1;i&amp;lt;strs.length;i++){ let tmp = &#39;&#39;; for(let j = 0; j&amp;lt;strs[i].length;j++){ if(strs[i][j]!=commonPrefix[j]) break; tmp += strs[i][j] } if(tmp.length&amp;lt;commonPrefix.length) commonPrefix = tmp } return commonPrefix};후기 Edge Case(가령 strs의 길이가 0인 경우)에 대해 작성하지 않았다. 다음에는 해당 부분 역시 고려할 것. Time Complexity와 Space Complexity 정확한 값 역시 생각할 것." } ]
